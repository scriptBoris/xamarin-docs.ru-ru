---
title: Транзакции и проверки в Xamarin.iOS
description: В этом документе описывается, как для восстановления прошлых покупок в приложении Xamarin.iOS. Здесь также рассматриваются способы защиты покупок и предоставление сервером продуктов.
ms.prod: xamarin
ms.assetid: 84EDD2B9-3FAA-B3C7-F5E8-C1E5645B7C77
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/18/2017
ms.openlocfilehash: 83f5fd233c004271169a4d00d0a65e70aa925b95
ms.sourcegitcommit: e268fd44422d0bbc7c944a678e2cc633a0493122
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "50117659"
---
# <a name="transactions-and-verification-in-xamarinios"></a>Транзакции и проверки в Xamarin.iOS

## <a name="restoring-past-transactions"></a>Восстановление предыдущих транзакций

Если приложение поддерживает типы продуктов, которые могут быть восстановлены, необходимо включить некоторые элементы пользовательского интерфейса, чтобы пользователи могли восстановить эти покупки.
Благодаря этому клиент для добавления продукта дополнительных устройств или восстановление продукта на то же устройство после очистить или удаления и переустановки приложения. Которые могут быть восстановлены являются следующие типы продуктов:

-  Продукты не использоваться моделью
-  Auto возобновляемую подписок
-  Бесплатные подписки

Процесс восстановления должен обновить записи сохранить на устройстве для удовлетворения ваших продуктов. Клиента можно восстановить в любое время, на любых устройствах. Процесс восстановления повторно отправляет все предыдущие транзакции для пользователя. код приложения следует определить какое действие необходимо выполнить с этими данными (например, проверка записи о покупке на устройстве уже существует, если нет, создается запись покупки и включение продукта для пользователя).

### <a name="implementing-restore"></a>Реализация восстановления

Пользовательский интерфейс **восстановить** кнопка вызывает следующий метод, который запускает RestoreCompletedTransactions `SKPaymentQueue`.

```csharp
public void Restore()
{
   // theObserver will be notified of when the restored transactions start arriving <- AppStore
   SKPaymentQueue.DefaultQueue.RestoreCompletedTransactions();
}
```

StoreKit отправит запрос на восстановление серверы Apple асинхронно.   
   
Так как `CustomPaymentObserver` регистрируется как наблюдатель транзакции, он будет получать сообщения при Apple серверы отвечают. Ответ будет содержать все транзакции, которые этот пользователь операций в этом приложении (для всех своих устройств). Этот код в цикле каждая транзакция обнаруживает состояние восстановления и вызовы `UpdatedTransactions` метод для его обработки, как показано ниже:

```csharp
// called when the transaction status is updated
public override void UpdatedTransactions (SKPaymentQueue queue, SKPaymentTransaction[] transactions)
{
   foreach (SKPaymentTransaction transaction in transactions)
   {
       switch (transaction.TransactionState)
       {
       case SKPaymentTransactionState.Purchased:
          theManager.CompleteTransaction(transaction);
           break;
       case SKPaymentTransactionState.Failed:
          theManager.FailedTransaction(transaction);
           break;
       case SKPaymentTransactionState.Restored:
           theManager.RestoreTransaction(transaction);
           break;
default:
           break;
       }
   }
}
```

Если отсутствуют продукты, которые могут быть восстановлены для пользователя, `UpdatedTransactions` не вызывается.   
   
Самый простой возможных код для восстановления данной транзакции в образце выполняет те же действия, что при Покупка выполняется, за исключением случаев, `OriginalTransaction` свойство используется для доступа к код продукта:

```csharp
public void RestoreTransaction (SKPaymentTransaction transaction)
{
   // Restored Transactions always have an 'original transaction' attached
   var productId = transaction.OriginalTransaction.Payment.ProductIdentifier;
   // Register the purchase, so it is remembered for next time
   PhotoFilterManager.Purchase(productId); // it's as though it was purchased again
   FinishTransaction(transaction, true);
}
```

Более сложные реализации могут проверять другие `transaction.OriginalTransaction` свойства, такие как исходный номер даты и приемки. Эти сведения будут полезны для некоторых типов продукта (например, подписки).

#### <a name="restore-completion"></a>Завершение восстановления

`CustomPaymentObserver` Имеет две дополнительные методы, которые будут вызваны StoreKit после завершения процесса восстановления (успешно или со сбоем), показано ниже:

```csharp
public override void PaymentQueueRestoreCompletedTransactionsFinished (SKPaymentQueue queue)
{
   Console.WriteLine(" ** RESTORE Finished ");
}
public override void RestoreCompletedTransactionsFailedWithError (SKPaymentQueue queue, NSError error)
{
   Console.WriteLine(" ** RESTORE FailedWithError " + error.LocalizedDescription);
}
```

В примере эти методы ничего не делать; Однако в реальном приложении, можно реализовать сообщение для пользователя или другие функциональные возможности.

## <a name="securing-purchases"></a>Обеспечение безопасности покупки

В двух примерах этого документа используйте `NSUserDefaults` для отслеживания покупки:   
   
 **Расходных** — «баланс» покупки кредит — это простой `NSUserDefaults` целочисленное значение, которое увеличивается при каждой покупке.   
   
 **Non-расходных** — каждой покупки фильтра photo сохраняется как пара "ключ значение" в `NSUserDefaults`.

С помощью `NSUserDefaults` сохраняют простой пример кода, но не предлагают решения очень надежным, как это возможно для пользователей с технической точки зрения стандартную для обновления параметров (обход механизма оплаты).   
   
Примечание: Реальных приложениях следует внедрять безопасный механизм для хранения, приобретенных содержимое, которое не является уязвимы для несанкционированного доступа пользователя. Для этого может потребоваться шифрование и/или других методов, включая идентификацию удаленным сервером.   
   
 Механизм должны разрабатываться также пользоваться преимуществами встроенных функций резервного копирования и восстановления операций ввода-вывода, iTunes и iCloud. Это гарантирует, что после пользователь восстанавливает резервную копию своих предыдущих покупок будут немедленно доступны.   
   
См. Apple безопасного кодирования руководстве Дополнительные инструкции для конкретных операций ввода-вывода.

## <a name="receipt-verification-and-server-delivered-products"></a>Проверки поступления и предоставление сервером продуктов

Примеры в этом документе, в данный момент включал только приложение взаимодействует непосредственно с серверами App Store для проведения операций покупки, которые разблокировать функции и возможности, которые уже в коде в приложение.   
   
Apple предоставляет получить дополнительный уровень безопасности покупки, позволяя покупки независимо друг от друга проверяемую защищен другим сервером, что может оказаться полезным для проверки запроса перед доставкой цифрового содержимого в процессе покупки (таких как цифровые книги или журнал).   
   
 **Встроенные продуктов** — как показано в примерах в этом документе приобретенный товар существует как функциональные возможности, в состав приложения. Покупка из приложения позволяет пользователю доступ к функциям.
Коды продуктов жестко запрограммированы.   
   
 **Предоставление сервером продуктов** — продукт состоит из загрузки содержимого, которое хранится на удаленном сервере, пока не будет успешно транзакция вызывает загрузку содержимого.
Примеры могут включать книги или выпуски magazine. Коды продуктов обычно получают данные из внешнего сервера (где продукта также размещается содержимое). Приложения должны реализовать надежного записи после завершения транзакции, таким образом, если содержимое загрузка завершается ошибкой может быть повторена без запутать пользователя.

### <a name="server-delivered-products"></a>Предоставление сервером продуктов

Некоторые продукта содержимого, такие как книг и журналов (или даже уровня игры) необходимо загрузить с удаленного сервера во время покупки. Это означает, что требуется для хранения и предоставления содержимого продукта после приобретения дополнительного сервера.

#### <a name="getting-prices-for-server-delivered-products"></a>Получение цен для продуктов, предоставление сервером

Поскольку продукты предоставляются удаленно, это также можно добавить дополнительные продукты со временем (без изменения кода приложения), таких как добавление дополнительные книги или новых проблемах журнала. Приложение может обнаружить эти продукты новостей и отображать их для пользователя, дополнительного сервера следует хранения и предоставления этой информации.   
   
[![](transactions-and-verification-images/image38.png "Получение цен для продуктов, предоставление сервером")](transactions-and-verification-images/image38.png#lightbox)   
   
1. Сведения о продукте, которые должны храниться в нескольких местах: на сервере и в iTunes Connect. Кроме того каждый продукт будет иметь файлы содержимого, связанные с ним. Эти файлы будут доставлены после успешного покупки.   
   
2. Когда пользователь хочет приобрести продукт, приложение должно определить, какие продукты доступны. Эта информация может быть кэширован, но должно быть доставлено с удаленного сервера, где хранится список продуктов.   
   
3. Сервер возвращает список идентификаторов продукта для приложения для синтаксического анализа.   
   
4. Затем приложение определяет, какие из этих кодов продуктов для отправки в StoreKit для получения цены и описания.   
   
5. StoreKit отправляет список идентификаторов продукта на серверах компании Apple.   
   
6. На время ответа сервера iTunes с соответствующим продуктом сведения (описание и текущая цена).   
   
7. Приложения `SKProductsRequestDelegate` передается сведения о продукте для отображения пользователю.

#### <a name="purchasing-server-delivered-products"></a>Приобретение предоставление сервером продуктов

Так как удаленный сервер требуется каким-либо образом проверки, что запрос на содержимое является допустимым (т. е. выплаченная для), о прочтении передается для проверки подлинности. Удаленный сервер пересылает их в iTunes для проверки подлинности и в случае успешного выполнения включает содержимое продукта в ответ на приложение.   
   
 [![](transactions-and-verification-images/image39.png "Приобретение предоставление сервером продуктов")](transactions-and-verification-images/image39.png#lightbox)   
   
1. Приложение добавляет `SKPayment` в очередь. При необходимости, пользователю будет предложено ввести свой идентификатор Apple, а запрос на подтверждение оплаты.   
   
2. StoreKit отправляет запрос на сервер для обработки.   
   
3. После завершения транзакции, сервер отвечает с уведомлением о транзакции.   
   
4. `SKPaymentTransactionObserver` Подкласс получает приемки и обрабатывает его. Так как продукт должен загружаться с сервера, приложение инициирует сетевой запрос к удаленному серверу.   
   
5. Запрос на загрузку сопровождается поступления данных, удаленный сервер убедиться в том, что она авторизована для доступа к содержимому. Приложения сетевой клиент ожидает ответа на этот запрос.   
   
6. Когда сервер получает запрос на содержимое, он проводит анализ поступления данных и отправляет запрос непосредственно к серверам iTunes на проверку приемки является допустимым транзакции. Сервер должен использовать определенную логику, чтобы определить, следует ли отправлять запрос к URL-адрес рабочей среды или песочницы. Apple предлагает всегда с помощью URL-адреса производственной и переключения на "песочницы", если ваш статус 21007 (поступление "песочницы" отправляемые рабочего сервера). Ссылаться на Apple [руководство по программированию проверки поступления](https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html) для получения дополнительных сведений.
   
7. iTunes проверка приемки и возвращать нулевое состояние, если оно допустимо.   
   
8. Сервер ждет ответа iTunes. Если он получает допустимый ответ, код определит файл содержимого связанных продуктов для включения в ответ в приложение.   
  
9. Приложение получает и анализирует ответ, сохранение содержимого продукта к файловой системе устройства.   
   
10. Приложение позволяет продукта, а затем вызывает его StoreKit `FinishTransaction`. Приложение может при необходимости отображения приобретенных содержимого (например, show первой страницы приобретенных книги или magazine проблема).

Альтернативную реализацию для файлов содержимого очень большого продукта может включать просто хранения получение транзакции на шаге #9 таким образом, можно быстро выполнить транзакцию и предоставление пользовательского интерфейса для пользователя для загрузки содержимого программных продуктов через некоторое время. Запрос на загрузку последующих можно повторно отправить хранимых получение доступа к файлу содержимого продукта.

### <a name="writing-server-side-receipt-verification-code"></a>Написание кода проверки поступления на стороне сервера

Проверка получения в серверный код может выполняться с помощью простого HTTP POST запрос ответ, охватывающий шаги с 5 # по #8 на схеме рабочего процесса.   
   
Извлеките `SKPaymentTansaction.TransactionReceipt` свойства в приложении. Это данные, необходимо отправить в iTunes для проверки подлинности (шаг #5).

Кодирование base64 поступления данных транзакций (либо на шаге #5 или #6).

Создайте простой полезные данные JSON следующим образом:

```csharp
{
   "receipt-data" : "(base-64 encoded receipt here)"
}
```

HTTP POST JSON в [ https://buy.itunes.apple.com/verifyReceipt ](https://buy.itunes.apple.com/verifyReceipt) для рабочей среды или [ https://sandbox.itunes.apple.com/verifyReceipt ](https://sandbox.itunes.apple.com/verifyReceipt) для тестирования.   
   
 Ответ JSON, будет содержать следующие ключи:

```csharp
{
   "status" : 0,
   "receipt" : { (receipt repeated here) }
}
```

Состояние 0 указывает уведомление допустимым. Сервер можно перейти к выполнения содержимое приобретаемой продукции. Получение ключа содержит словарь JSON с теми же свойствами, что `SKPaymentTransaction` объекта, полученного приложением, поэтому серверный код можно запросить этот словарь для получения сведений, таких как Идентификатор_продукта и количество покупки.

См. в разделе Apple [руководство по программированию проверки поступления](https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Introduction.html) системному администратору.
