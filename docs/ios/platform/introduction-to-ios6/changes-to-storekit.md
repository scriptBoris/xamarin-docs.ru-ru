---
title: Изменения в StoreKit в iOS 6
description: 'iOS 6 представлены два изменения в API Store Kit: возможность отображать iTunes (и App Store/iBookstore) вариант, где Apple будет разместить загружаемые файлы покупки продуктов в приложении и в приложение. В этом документе объясняется, как для реализации таких возможностей с помощью Xamarin.iOS.'
ms.prod: xamarin
ms.assetid: 253D37D7-44C7-D012-3641-E15DC41C2699
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/19/2017
ms.openlocfilehash: 5d1bb5ab636cd7527a560332a9890e9907fac454
ms.sourcegitcommit: e268fd44422d0bbc7c944a678e2cc633a0493122
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "50118322"
---
# <a name="changes-to-storekit-in-ios-6"></a>Изменения в StoreKit в iOS 6

_iOS 6 внесли два изменения в API Store Kit: возможность отображать iTunes (и App Store/iBookstore) вариант, где Apple будет разместить загружаемые файлы покупки продуктов в приложении и в приложение. В этом документе объясняется, как для реализации таких возможностей с помощью Xamarin.iOS._

Основные изменения в Store Kit в iOS6 приведены эти две новые функции.

- **Отобразить содержимое в приложении & Purchasing** — пользователи могут приобрести подписку и загрузки приложений, музыки, книг и других iTunes содержимого, не выходя из приложения. Можно также связать свои собственные приложения для повышения приобретения или просто рекомендуем отзывы и оценки.
- **В приложении приобретения размещенного содержимого** — Apple будет хранить и предоставлять содержимое, связанное с вашей продукции Покупка из приложения, который устраняет потребность в отдельный сервер можно разместить файлы, автоматически поддерживает загрузку в фоновом режиме и позволяет писать меньше кода.

Ссылаться на [покупки в приложении](~/ios/platform/in-app-purchasing/index.md) руководства по подробное описание StoreKit API-интерфейсы.

## <a name="requirements"></a>Требования

Store Kit функциям, рассматриваемым в этом документе требуют iOS 6 и Xcode 4.5, а также Xamarin.iOS 6.0.

## <a name="in-app-content-display--purchasing"></a>Отображение содержимого в приложении и закупки

Новая функция приобретения в приложении в iOS позволяет пользователям просматривать сведения о продукте и купить и скачать продукт с помощью приложения.
Ранее приложений необходимо активировать iTunes App Store и iBookstore, что привело бы к пользователю, оставив исходное приложение. Эта новая функция автоматически возвращает пользователя к приложению, когда они выполняются.

[![](changes-to-storekit-images/image1.png "Автоматически возвращает в приложение после покупки")](changes-to-storekit-images/image1.png#lightbox)

Как это может использоваться примеры.

- **Поощряя пользователи вашего приложения** — можно открыть на странице App Store, чтобы пользователь мог оценить и проверить приложение, не выходя из него.
- **Повышение уровня нескольких приложений** — разрешить пользователю видеть другие приложения, которые вы публикуете, возможность приобрести/download немедленно.
- **Как помочь пользователям находить и загружать содержимое** — помочь пользователям купить содержимое, которое приложение находит управляет и объединяет (например) приложения, связанные с музыки может получать список воспроизведения тех песен и каждой песни приобретать в приложении).

Один раз `SKStoreProductViewController` отображения пользователь может взаимодействовать с сведения о продукте, как если бы они были в iTunes App Store и iBookstore. Пользователь может:

- Снимки экрана представления (для приложений)
- Пример песни или видео (для музыки, ТВ-передачи и фильмы)
- Обзоры чтения (и запись),
- & Загрузки, что происходит только в контроллер представления и Store Kit покупки.

Некоторые параметры в `SKStoreProductViewController` будет по-прежнему принудительно пользователю оставить приложение и откройте приложение соответствующем магазине, например, нажатие **связанные продукты** или приложения **поддержки** ссылку.

### <a name="skstoreproductviewcontroller"></a>SKStoreProductViewController

API-Интерфейс для отображения продуктов в любое приложение является простой: требуется только создать и отобразить `SKStoreProductViewController`. Выполните следующие действия для создания и отображения продукта.

1. Создание `StoreProductParameters` объект для передачи параметров в контроллер представления, включая `productId` в конструкторе.
1. Создать экземпляр `SKProductViewController`. Назначьте поле уровня класса.
1. Назначить обработчик, на контроллер представления `Finished` событие, которое следует закрыть контроллер представления. Это событие вызывается в том случае, когда пользователь нажимает клавишу отмены; или в противном случае завершает транзакцию внутри контроллера представления.
1. Вызовите `LoadProduct` метод передавая `StoreProductParameters` и завершающий обработчик. Обработчик завершения должен проверить, что запрос продукта успешно и если да, представлять `SKProductViewController` модальном режиме. В случае, если не удается получить продукта, следует добавить соответствующую обработку ошибок.

### <a name="example"></a>Пример

*ProductView* в проекте *StoreKit* реализует пример кода для этой статьи `Buy` идентификатор Apple-метод, который принимает любой продукт и отображает `SKStoreProductViewController`. Следующий код отображает сведения о продукте для любого заданного идентификатора Apple ID:

```csharp
void Buy (int productId)
{
    var spp = new StoreProductParameters(productId);
    var productViewController = new SKStoreProductViewController ();
    // must set the Finished handler before displaying the view controller
    productViewController.Finished += (sender, err) => {
        // Apple's docs says to use this method to close the view controller
        this.DismissModalViewControllerAnimated (true);
    };
    productViewController.LoadProduct (spp, (ok, err) => { // ASYNC !!!
        if (ok) {
            PresentModalViewController (productViewController, true);
        } else {
            Console.WriteLine (" failed ");
            if (err != null)
                Console.WriteLine (" with error " + err);
        }
    });
}
```

Приложение выглядит как на снимке экрана ниже, при выполнении — скачивания или приобретения происходит только в среде `SKStoreProductViewController`:

[![](changes-to-storekit-images/image2.png "Приложение выглядит следующим образом, при запуске")](changes-to-storekit-images/image2.png#lightbox)

### <a name="supporting-older-operating-systems"></a>Поддержка старых операционных систем

Образец приложения включает кода, показывающий, как открыть в более ранних версиях iOS App Store, iTunes или iBookstore. Используйте `OpenUrl` метод, чтобы открыть правильно сконструированное **itunes.com** URL-адрес.

Можно реализовать проверку версий, чтобы определить, какой код для запуска, как показано ниже:

```csharp
if (UIDevice.CurrentDevice.CheckSystemVersion (6,0)) {
    // do iOS6+ stuff, using SKStoreProductViewController as shown above
} else {
    // don't do stuff requiring iOS 6.0, use the old syntax 
    // (which will take the user out of your app)
    var nsurl = new NSUrl("http://itunes.apple.com/us/app/angry-birds/id343200656?mt=8");
    UIApplication.SharedApplication.OpenUrl (nsurl);
}
```

### <a name="errors"></a>Ошибки

При этом возникнет следующая ошибка, если недопустимый идентификатор Apple, использовании, что может вызывать путаницу с момента его подразумевает проблемы с сетью или проверки подлинности какого-либо рода.

 `Error Domain=SKErrorDomain Code=5 "Cannot connect to iTunes Store"`

### <a name="reading-objective-c-documentation"></a>Чтению документации, Objective-C

Разработчики, изучив информацию о Store пакета на портале разработчика Apple будет отображен протокол — [SKStoreProductViewControllerDelegate](https://developer.apple.com/library/prerelease/ios/#documentation/StoreKit/Reference/SKITunesProductViewControllerDelegate_ProtocolRef/Reference/Reference.html) — описанных по отношению к этой новой функции. Протокол делегат имеет только один метод — productViewControllerDidFinish — был предоставлен как `Finished` событий на `SKStoreProductViewController` в Xamarin.iOS.

## <a name="determining-apple-ids"></a>Определение идентификаторы Apple ID

Идентификатор Apple ID, требующегося `SKStoreProductViewController` — *номер* (не следует путать с идентификаторами пакета как «com.xamarin.mwc2012»). Существует несколько разных способов, чтобы узнать идентификатор Apple ID для продуктов, которые нужно отобразить, перечисленных ниже:

### <a name="itunesconnect"></a>iTunesConnect

Для приложений, публикации, несложно найти **идентификатор Apple ID** в iTunes Connect:

[![](changes-to-storekit-images/image3.png "Поиск идентификатора Apple ID в iTunes Connect")](changes-to-storekit-images/image3.png#lightbox)

 <a name="Search_API" />

### <a name="search-api"></a>API поиска

Apple предоставляет API для динамического поиска для запроса всех продуктов в App Store, iTunes и iBookstore. Сведения о том, как получить доступ к API поиска можно найти в [прикрепить ресурсы компании Apple](http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html), несмотря на то, что API предоставляет всем (не только что зарегистрированным аффилированных лиц). Полученные данные JSON могут быть проанализированы для обнаружения `trackId` то есть идентификатор Apple ID для использования с `SKStoreProductViewController`.

Результаты также включают другие метаданные, включая сведения об отображении и иллюстрации URL-адреса, которые могут использоваться для подготовки к просмотру продукта в вашем приложении.

Далее приводятся некоторые примеры.

- **приложения iBooks** — [ http://itunes.apple.com/search?term=ibooks&amp; сущности = программного обеспечения&amp;country = us](http://itunes.apple.com/search?term=ibooks&amp;entity=software&amp;country=us)
- **IBook с днем рождения... и точками** — [ http://itunes.apple.com/search?term=dot+and+the+kangaroo&amp; сущности = электронная книга&amp;country = us](http://itunes.apple.com/search?term=dot+and+the+kangaroo&amp;entity=ebook&amp;country=us)

### <a name="enterprise-partner-feed"></a>Веб-канал Enterprise партнера

Apple предоставляет утвержденных партнеров с полным данным дамп всех продуктов, в виде неструктурированных файлов для загрузки готовых к базе данных. Если вы удовлетворяете требованиям для доступа к [Enterprise партнера веб-канала](http://www.apple.com/itunes/affiliates/resources/documentation/itunes-enterprise-partner-feed.html), а затем идентификатор Apple ID для любого продукта можно найти в наборе данных.

Многие пользователи веб-канала партнера Enterprise являются членами [прикрепить программы](http://www.apple.com/itunes/affiliates) , позволяющий комиссионные нужно заслужить на продажи продукта. `SKStoreProductViewController` не поддерживает идентификаторы партнера (на момент написания этой статьи).

### <a name="direct-product-links"></a>Прямые ссылки по продукту

Идентификатор Apple ID для продукта можно вывести из его iTunes URL-адрес предварительного просмотра ссылки.
Найдите часть URL-адреса, начиная с в любой iTunes ссылки по продукту (для приложений, музыки или книг) `id` и использовать число, следующее.

Например имеет прямую ссылку на iBooks

```csharp
http://itunes.apple.com/us/app/ibooks/id364709193?mt=8
```

значение идентификатора Apple **364709193**. Аналогичным образом для приложения MWC2012, прямая ссылка будет

```csharp
http://itunes.apple.com/us/app/mwc-2012-unofficial/id496963922?mt=8
```

значение идентификатора Apple **496963922**.

## <a name="in-app-purchase-hosted-content"></a>Покупка из приложения размещенного содержимого

Если ваши покупки в приложении состоят из загружаемому содержимому (например, книги или другого носителя, игр коллекцией уровней и конфигурации или других больших файлов) затем эти файлы используются для размещения на веб-сервере, и приложения должны были внедрять код, чтобы безопасно загрузить их после приобрести. Начиная с iOS 6, Apple будет разместить файлы на своих серверах устраняется необходимость в отдельном сервере. Эта функция доступна только для продуктов не использоваться моделью (не использоваться моделью или подписки). Ниже перечислены преимущества использования службы размещения Apple:

- Сократите затраты на размещение и пропускной способности.
- Вероятно, большую масштабируемость, чем независимо от узла сервера, используемой в текущий момент. 
- Меньше кода для записи, так как не нужно создавать обработку на стороне сервера. 
- Загрузка фона реализуется автоматически.

Примечание: тестирование размещенного содержимого покупки из приложений в iOS Simulator не поддерживается, поэтому необходимо выполнить тестирование с помощью реального устройства.

### <a name="hosted-content-basics"></a>Основы размещенного содержимого

До версии iOS 6, существует было два способа указания продукта (более подробно в [покупки в приложении Xamarin](~/ios/platform/in-app-purchasing/index.md) документации):

- **Встроенные продуктов** — функции, являются «разблокировано» путем приобретения, но, встроенные в приложение (либо как код или внедренные ресурсы). Встроенные продуктов примеры разблокирован фото фильтры или бонусов в игре.
- **Предоставление сервером продуктов** — после покупки, приложение необходимо загрузить содержимое с сервера, который вы работаете. Это содержимое загружается во время покупки, хранящихся на устройстве и выводятся в виде часть, предоставляющая продукта. Примеры включают книг, выпуски magazine или игровые уровни, которые состоят из фона картинок и файлов конфигурации.

В iOS 6 Apple предлагает вариант доставить server продуктов: они будут размещаться файлы содержимого на их серверах. Это делает гораздо проще выполнить сборку предоставление сервером продуктов, поскольку не является обязательным для работы на отдельном сервере, и Store Kit функциональными возможностями, загрузку в фоновом режиме, необходимо сначала написать самостоятельно. Чтобы воспользоваться преимуществами размещения компании Apple, размещения содержимого в новых продуктах Покупка из приложения и изменить Store Kit код, чтобы воспользоваться его преимуществами. Затем файлы содержимого продукта созданные с помощью Xcode и передан на серверы корпорации Apple для проверки и выпуска.

[![](changes-to-storekit-images/image4.png "В процессе сборки и доставки")](changes-to-storekit-images/image4.png#lightbox)

С помощью App Store для предоставления покупки из приложений *с размещенного содержимого* требуются следующие программы установки и конфигурации:

- **iTunes Connect** — вы *необходимо* уже предоставили вашей банковские и налоговые данные в Apple, так что они могут переводим средств, собранные от вашего имени. Затем можно настроить продавать и настройка учетных записей пользователей "песочницы" для тестирования приобретения продуктов.  _Необходимо также настроить Hosted Content неготовых продуктов, на которых вы хотите разместить с Apple_.
- **Портал подготовки iOS** — Создание идентификатора пакета и включение доступа к App Store для приложения, как это делается для любого приложения, который поддерживает покупки из приложений.
- **Store Kit** — Добавление кода в приложение для отображения продуктов, приобретения продуктов и отмены транзакций.  _В iOS 6 Store Kit также будет управлять загрузкой содержимого продукта, в фоновом режиме, с помощью обновлений хода выполнения._
- **Пользовательский код** — чтобы отслеживать покупки, совершенные клиентами и предоставлять товары или услуги, которые они приобрели. Использовать новые классы Store Kit iOS 6, например `SKDownload` для получения содержимого, размещенного в Apple.

В следующих разделах Реализация размещенное содержимое, создание и отправка пакета управления покупки и загрузить процесса, используя образец кода для этой статьи.

### <a name="sample-code"></a>Пример кода

Пример проекта *HostedNonConsumables* (в StoreKitiOS6.zip) использует размещенного содержимого. Приложение предлагает два» главы «для продажи, содержимое, для которого размещается на серверах компании Apple. Содержимое состоит из текстового файла или изображения, несмотря на то, что гораздо более сложное содержимое может использоваться в реальном приложении.

До, во время и после покупки, приложение выглядит следующим образом:

 [![](changes-to-storekit-images/image5.png "Приложение выглядит до, во время и после покупки")](changes-to-storekit-images/image5.png#lightbox)

Текстовый файл и изображения загружаются и копируются в каталог приложения документов. Дополнительные сведения о разных каталогах, доступны для хранилища приложений, см. в разделе [файл документации по системе](~/ios/app-fundamentals/file-system.md).

## <a name="itunes-connect"></a>iTunes Connect

При создании новых продуктов, которые будут использовать Apple содержимого размещения, не забудьте выбрать **использоваться моделью не** тип продукта. Другие типы продукта не поддерживают размещение содержимого. Кроме того, не следует включать размещение содержимого для *существующие* продукты, Продажа; только включить размещение содержимого в новых продуктах.

 [![](changes-to-storekit-images/image6.png "Выберите тип продукта не использоваться моделью")](changes-to-storekit-images/image6.png#lightbox)

Введите **идентификатор продукта**. Этот идентификатор потребуется позднее при создании содержимого для этого продукта.

 [![](changes-to-storekit-images/image7.png "Введите идентификатор продукта")](changes-to-storekit-images/image7.png#lightbox)

Размещение содержимого задается в разделе "Сведения". Перед запуском покупки из приложений, снимите флажок **содержимого узла с помощью Apple** флажок, если вы хотите отменить (даже если вы отправили тестовое содержимое). Однако размещение содержимого нельзя удалить после покупки в приложении пошло динамической.

 [![](changes-to-storekit-images/image8.png "Размещение содержимого с Apple.")](changes-to-storekit-images/image8.png#lightbox)

После включения на размещение содержимого, перейдет в продукт **ожидание передачи** состояния и показывать это сообщение:

 [![](changes-to-storekit-images/image9.png "Введите ожидания для передачи состояния и показывать это сообщение будет продукта")](changes-to-storekit-images/image9.png#lightbox)

Пакет содержимого должен быть создан с помощью Xcode и загружаются с помощью средства архива. В следующем разделе приведены инструкции по созданию пакетов содержимого **создание. Файлы PKG**.

## <a name="creating-pkg-files"></a>Создание. PKG-файлов

Файлы содержимого, которые передаются в Apple должен удовлетворять следующим ограничениям:

- Размер не может превышать 2 ГБ.
- Не может содержать исполняемый код (или символических ссылок, точек за пределами содержимое).
- Должен иметь корректный формат (включая **.plist** файл) и иметь **.pkg** расширение файла. Это будет сделано автоматически, если вы выполните эти инструкции, с помощью Xcode.

Множество разные файлы и типы файлов, можно добавить до тех пор, пока они соответствует этим ограничениям. Содержимое ZIP-архив перед доставкой приложению и распаковываются по Store Kit, прежде чем код обращается к.

После загрузки содержимого пакета, его можно заменить новое содержимое. Новое содержимое должно быть загружено и передан для просмотра и утверждения, с помощью обычного процесса. Приращение `ContentVersion` в обновленных пакетов содержимого, чтобы указать, что он является более новым.

### <a name="xcode-in-app-purchase-content-projects"></a>Xcode в приложении покупки проектов

В настоящее время создания пакетов содержимого для продуктов покупки в приложении требуется Xcode. Нет, нет OBJECTIVE-C требует дополнительного ПРОГРАММИРОВАНИЯ; Xcode не новый тип проекта для этих пакетов, просто содержит файлы и plist.

Наш пример приложения имеет главы для продажи: будет содержать каждый пакет содержимого главы:

-  текстовый файл, и
-  изображение для представления в главе.


Начните с выбора **файл > Новый проект** в меню и выбрав **содержимого покупки в приложении**:

 [![](changes-to-storekit-images/image10.png "Выбрать содержимое Покупка из приложения")](changes-to-storekit-images/image10.png#lightbox)

Введите **название продукта** и **идентификатор компании** таким образом, чтобы **идентификатор пакета** соответствует **идентификатор продукта** , введенный в iTunes Подключение для этого продукта.

[![](changes-to-storekit-images/image11.png "Введите имя и идентификатор")](changes-to-storekit-images/image11.png#lightbox)

Теперь у вас будет пустое **содержимого покупки в приложении** проекта. Щелкнуть правой кнопкой мыши и **добавить файлы...** или перетащите их в **навигатор проекта**. Убедитесь, что **ContentVersion** правильно (он должен начинаются с 1.0, но если позже вы решили обновить содержимое, не забудьте увеличить его).

На этом снимке экрана показана Xcode содержимого файлы, включенные в проект и plist видимых в главном окне:

[![](changes-to-storekit-images/image12.png "На этом снимке экрана показан Xcode с содержимого файлы, включенные в проект и plist видимых в главном окне")](changes-to-storekit-images/image12.png#lightbox)

После добавления всех файлов содержимого можно сохранить этот проект и изменить его позже или начать процесс отправки.

## <a name="uploading-pkg-files"></a>Отправка. PKG-файлов

Самый простой способ отправки пакетов содержимого — с **средство Xcode архив**. Выберите **продукта > архив** меню, чтобы начать:

![](changes-to-storekit-images/image13.png "Выберите Archiven")

Пакет содержимого появится в архиве, как показано ниже. Тип архива и значок Показать эта линия — **содержимого архива покупки в приложении**. Нажмите кнопку **проверки...** для нашего пакета содержимого для ошибок проверки без фактического выполнения отправки.

[![](changes-to-storekit-images/image14.png "Проверка пакета")](changes-to-storekit-images/image14.png#lightbox)

Имя для входа с помощью iTunes Connect: учетные записи:

[![](changes-to-storekit-images/image15.png "Имя входа с помощью iTunes Connect: учетные записи")](changes-to-storekit-images/image15.png#lightbox)

Выберите нужное приложение и Покупка из приложения, чтобы связать это содержимое с:

[![](changes-to-storekit-images/image16.png "Выберите нужное приложение и Покупка из приложения, чтобы связать это содержимое с")](changes-to-storekit-images/image16.png#lightbox)

Вы должны увидеть примерно на этом снимке экрана сообщение:

![Пример сообщения без проблем](changes-to-storekit-images/image17.png "пример сообщения без проблем")

Теперь пройти процесс, аналогичный, но щелкнув **распределить...** фактически будет передать содержимое.

[![Распространение приложения](changes-to-storekit-images/image18.png "распространение приложения")](changes-to-storekit-images/image18.png#lightbox)

Выберите первый вариант, чтобы передать содержимое:

![Передать содержимое](changes-to-storekit-images/image19.png "передать содержимое")

Снова войти в систему:

[![](changes-to-storekit-images/image15.png "Имя входа в")](changes-to-storekit-images/image15.png#lightbox)

Выберите нужное приложение и записи Покупка из приложения для отправки содержимого:

[![](changes-to-storekit-images/image20.png "Выберите запись приложения и в приложении покупки")](changes-to-storekit-images/image20.png#lightbox)

Подождите, пока файлы будут загружены:

[![](changes-to-storekit-images/image21.png "Диалоговое окно отправки содержимого")](changes-to-storekit-images/image21.png#lightbox)

При завершении передачи, чтобы сообщить вам, что содержимое был отправлен в App Store будет отображаться сообщение.

[![](changes-to-storekit-images/image22.png "Пример успешной отправки сообщения")](changes-to-storekit-images/image22.png#lightbox)

Когда это сделано, вернувшись на страницу продуктов в iTunes Connect будет показывать сведения о пакете и находиться в **готовы отправить** состояния. После выпуска продукта в это состояние, вы сможете начать тестирование в изолированной среде. Необходимо отправить продукт для тестирования в изолированной среде.

[![](changes-to-storekit-images/image23.png "iTunes Connect, он будет отображать сведения о пакете и быть готовы к состояние отправки")](changes-to-storekit-images/image23.png#lightbox)

Это может занять некоторое время (например) через несколько минут) между передача архива и статус iTunes Connect выполняется обновление. Можно отправить продукта для проверки отдельно или отправить его в сочетании с двоичный файл приложения. Только в том случае, получив Apple официально утверждение содержимого он будет в рабочей среде App Store для приобретения в вашем приложении.

### <a name="pkg-file-format"></a>Формат файла ПАКЕТА

С помощью Xcode и средства архив, как создать и передать размещенного содержимого пакета, это означает, что вы никогда не видеть содержимое самого пакета. Файлы и каталоги в пакеты, созданные для образца приложения выглядят на снимке экрана ниже, с помощью **plist** файл в корне и файлы продукта в **содержимое** подкаталоге:

[![](changes-to-storekit-images/image24.png "Файл plist-файл в корне и файлы продукта в подкаталоге содержимое")](changes-to-storekit-images/image24.png#lightbox)

Обратите внимание, структура каталогов пакета (особенно расположение файлов в `Contents` подкаталог) так, как вам потребуется понять эту информацию, чтобы извлечь файлы из пакета на устройстве.

### <a name="updating-package-content"></a>Обновление содержимого пакета

Процедура обновления содержимого после его утверждения:

- Изменение содержимого покупки в приложении проект в Xcode.
- Увеличьте номер версии.
- Повторите отправку в iTunes Connect. Последующие покупателей автоматически получат последнюю версию, но у пользователей уже установлена старая версия не получат никаких уведомлений.
- Приложение отвечает за уведомление пользователей и способствования их для получения более новой версии содержимого. Приложение также необходимо создать функцию, которая загружает эту версию, с помощью функции восстановления Store Kit.
- Чтобы определить, существует ли более новая версия, функцию можно встроить в приложения, чтобы получить SKProducts (например) же процесс, который используется для получения цены продукта) и сравнить свойство ContentVersion.

## <a name="purchasing-overview"></a>Общие сведения о приобретении

Перед прочтением данного раздела просмотрите существующие [документации покупки в приложении](~/ios/platform/in-app-purchasing/index.md).

Последовательность событий, при которой продукт, размещенное содержимое приобретается и загрузки проиллюстрирован на следующей схеме:

[![](changes-to-storekit-images/image25.png "Последовательность событий, при которой продукт, размещенное содержимое приобретается и загрузить")](changes-to-storekit-images/image25.png#lightbox)

1. Новые продукты могут создаваться в iTunes Connect с Hosted Content включена. Фактическое содержимое создается отдельно в Xcode (в виде просто как перетаскивание файлов в папку) и после этого архивируются и отправить в iTunes (без написания кода не требуется). Каждый продукт, затем отправить на утверждение, после чего он становится доступным для покупки. В образце кода жестко запрограммированы эти коды продуктов, но размещение содержимого с помощью Apple является более гибким, при сохранении списка доступных продуктов на удаленном сервере, чтобы его можно обновить при отправке новых продуктов и содержимое в iTunes Connect.
1. Когда пользователь приобретает продукт, транзакции помещается в очередь оплаты для обработки.
1. Store Kit отправляет запрос на покупку iTunes серверов для обработки.
1. Транзакция завершается на серверах iTunes (например) плата взимается за клиента) и уведомление о возвращается в приложение с сведения о продукте, включая является ли этот файл можно подключить (и если да, размер файла и другие метаданные).
1. Код должен проверить, если загружаемая продукта и если это так сделать запрос загрузки содержимого, который помещается в очередь оплаты. Store Kit отправляет этот запрос к серверам iTunes.
1. Сервер возвращает файл содержимого Store Kit, который предоставляет обратный вызов для возвращения ход выполнения скачивания и время, оставшееся оценок в код.
1. После завершения, получить уведомление и передать расположение файла в папке кэша.
1. Код должен скопировать файлы и проверить их, сохранять любое состояние, которое необходимо помнить, что вы приобрели продукт. Воспользуйтесь этой возможностью для правильной установки флага резервного копирования для новых файлов (подсказка: если их появления на сервере и никогда не был изменен пользователем, следует, вероятно, пропустить их резервного копирования, так как пользователь всегда их можно получить от компании Apple серверов в будущем).
1. Вызовите FinishTransaction. Этот шаг не важно, так как оно снимает транзакции из очереди оплаты. Также важно не вызывайте FinishTransaction до, после копирования содержимого из каталога кэша. При вызове метода FinishTransaction, кэшированных файлов, скорее всего, быстро очистки.

## <a name="implementing-hosted-content-purchase"></a>Реализация размещенного содержимого покупки

Следующие сведения, которые должны считываться в сочетании с полный [документации покупки из приложений](~/ios/platform/in-app-purchasing/index.md). Сведения в этом документе рассматриваются различия между размещенное содержимое и предыдущей реализации.

### <a name="classes"></a>Классы

Следующие классы были добавлены или изменены для поддержки размещенного содержимого в iOS 6:

- **SKDownload** — новый класс, представляющий загрузкой. API позволяет более одного на продукта, однако изначально только один была реализована.
- **SKProduct** — добавлены новые свойства: `Downloadable`, `ContentVersion`, `ContentLengths` массива.
- **SKPaymentTransaction** — добавить новое свойство: `Downloads`, который содержит коллекцию `SKDownload` объекты, если этот продукт размещается содержимое, доступное для загрузки.
- **SKPaymentQueue** — добавлен новый метод: `StartDownloads`. Вызов этого метода с `SKDownload` объектов для получения их размещенное содержимое. Загрузка может произойти в фоновом режиме.
- **SKPaymentTransactionObserver** — новый метод: `UpdateDownloads`. Store Kit вызывает этот метод с выводятся сведения о текущей операции загрузки.

Сведения о новой `SKDownload` класса:

- **Ход выполнения** — значение в диапазоне от 0 до 1, можно использовать для отображения индикатора выполнения в процентах для пользователя. НЕ используйте ход выполнения == 1, чтобы определить, завершена ли загрузка, проверить состояние == завершен.
- **TimeRemaining** — оценка загрузки Осталось времени, в секундах. значение -1 означает, что он еще не завершила оценку.
- **Состояние** — активным в ожидании завершения, не удалось, приостановлен, отменена.
- **ContentURL** — расположение, куда было помещать содержимое на диске, в файла `Cache` каталога. Заполняется только после завершения загрузки.
- **Ошибка** — проверьте это свойство, если сбой состояния.

На этой схеме (код, характерный для размещенного содержимого покупки отображается зеленым цветом), показаны взаимодействия между классами в образце кода.

[![](changes-to-storekit-images/image26.png "Зеленым цветом на этой схеме показан размещенного содержимого покупки")](changes-to-storekit-images/image26.png#lightbox)

В оставшейся части в этом разделе показан пример кода, где используются эти классы:

### <a name="custompaymentobserver-skpaymenttransactionobserver"></a>CustomPaymentObserver (SKPaymentTransactionObserver)

Изменить существующий `UpdatedTransactions` переопределение, проверяемый на загружаемое содержимое и вызовите метод `StartDownloads` при необходимости:

```csharp
public override void UpdatedTransactions (SKPaymentQueue queue, SKPaymentTransaction[] transactions)
{
    foreach (SKPaymentTransaction transaction in transactions) {
        switch (transaction.TransactionState) {
        case SKPaymentTransactionState.Purchased:
            // UPDATED FOR iOS 6
            if (transaction.Downloads != null && transaction.Downloads.Length > 0) {
                // Purchase complete, and it has downloads... so download them!
                SKPaymentQueue.DefaultQueue.StartDownloads (transaction.Downloads);
                // CompleteTransaction() call has moved after downloads complete
            } else {
                // complete the transaction now
                theManager.CompleteTransaction(transaction);
            }
            break;
        case SKPaymentTransactionState.Failed:
            theManager.FailedTransaction(transaction);
            break;
        case SKPaymentTransactionState.Restored:
            // TODO: you must decide how to handle restored transactions.
            // Triggering all the downloads at once is not advisable.
            theManager.RestoreTransaction(transaction);
            break;
        default:
            break;
        }
    }
}
```

Новый переопределенный метод `UpdatedDownloads` показан ниже. Store Kit вызывает этот метод после `StartDownloads` активируется в `UpdatedTransactions`. Этот метод вызывается *несколько раз* неопределенном интервалы для предоставления вам ход загрузки и затем снова после завершения загрузки. Обратите внимание, что метод принимает массив `SKDownload` объектов, чтобы каждый вызов метода могли предоставить вам со статусом скачиванию нескольких файлов в очереди. Как показано в ниже реализация состояния загрузки: проверяется каждый раз и выполнены соответствующие действия.

```csharp
// ENTIRELY NEW METHOD IN iOS6
public override void PaymentQueueUpdatedDownloads (SKPaymentQueue queue, SKDownload[] downloads)
{
    Console.WriteLine (" -- PaymentQueueUpdatedDownloads");
    foreach (SKDownload download in downloads) {
        switch (download.DownloadState) {
        case SKDownloadState.Active:
            // TODO: implement a notification to the UI (progress bar or something?)
            Console.WriteLine ("Download progress:" + download.Progress);
            Console.WriteLine ("Time remaining:   " + download.TimeRemaining); // -1 means 'still calculating'
            break;
        case SKDownloadState.Finished:
            Console.WriteLine ("Finished!!!!");
            Console.WriteLine ("Content URL:" + download.ContentUrl);

            // UNPACK HERE! Calls FinishTransaction when it's done
            theManager.SaveDownload (download);

            break;
        case SKDownloadState.Failed:
            Console.WriteLine ("Failed"); // TODO: UI?
            break;
        case SKDownloadState.Cancelled:
            Console.WriteLine ("Canceled"); // TODO: UI?
            break;
        case SKDownloadState.Paused:
        case SKDownloadState.Waiting:
            break;
        default:
            break;
        }
    }
}
```

### <a name="inapppurchasemanager-skproductsrequestdelegate"></a>InAppPurchaseManager (SKProductsRequestDelegate)

Этот класс содержит новый метод `SaveDownload` , вызываемый после успешного завершения каждой загрузки.

Успешно загружено и распаковываются в размещенном содержимом `Cache` каталога. Структура. Файл PKG требуются все файлы, должен быть сохранен в `Contents` подкаталог, поэтому приведенный ниже код извлекает файлы из среды `Contents` подкаталог.

Код выполняет итерацию по всем файлам в пакете содержимого и копирует их в `Documents` каталог во вложенной папке с именем для `ProductIdentifier`. Наконец он вызывает `CompleteTransaction`, который вызывает `FinishTransaction` для удаления транзакции из очереди оплаты.

```csharp
// ENTIRELY NEW METHOD IN iOS 6
public void SaveDownload (SKDownload download)
{
    var documentsPath = Environment.GetFolderPath (Environment.SpecialFolder.Personal); // Documents folder
    var targetfolder = System.IO.Path.Combine (documentsPath, download.Transaction.Payment.ProductIdentifier);
    // targetfolder will be "/Documents/com.xamarin.storekitdoc.montouchimages/" or something like that
    if (!System.IO.Directory.Exists (targetfolder))
        System.IO.Directory.CreateDirectory (targetfolder);
    foreach (var file in System.IO.Directory.EnumerateFiles 
             (System.IO.Path.Combine(download.ContentUrl.Path, "Contents"))) { // Contents directory is the default in .PKG files
        var fileName = file.Substring (file.LastIndexOf ("/") + 1);
        var newFilePath = System.IO.Path.Combine(targetfolder, fileName);
        if (!System.IO.File.Exists(newFilePath)) // HACK: this won't support new versions...
            System.IO.File.Copy (file, newFilePath);
        else
            Console.WriteLine ("already exists " + newFilePath);
    }
    CompleteTransaction (download.Transaction); // so it gets 'finished'
}
```

Когда `FinishTransaction` вызове Скачанный файлы больше не обязательно будет в `Cache` directory. Все файлы должны копироваться перед вызовом `FinishTransaction`.


## <a name="other-considerations"></a>Другие вопросы

Приведенный выше пример демонстрирует достаточно простой реализации приобретения размещенного содержимого. Существуют некоторые дополнительные моменты, которые следует учитывать:

### <a name="detecting-updated-content"></a>Обнаружение обновленное содержимое

Хотя и существует возможность обновления размещенного содержимого пакетов, Store Kit предоставляет механизм для передачи этих обновлений на пользователей, которые уже его загрузили и приобрели продукт. Для реализации этой функции может проверить новый код `SKProduct.ContentVersion` свойства (если `SKProduct` — `Downloadable`) регулярно и обнаружить, если значение увеличивается. В качестве альтернативы можно построить системы push уведомлений.

### <a name="installing-updated-content-versions"></a>Установка обновленной версии содержимого

Приведенный выше пример кода пропускает копирование файлов, если файл уже существует. Это не рекомендуется, если вы хотите поддерживать более новых версиях скачиваемого содержимого.

Альтернативы можно скопировать содержимое в папку с именем для версии и отслеживать это текущая версия (например) в `NSUserDefaults` или везде, где хранятся записи завершенных покупки).

### <a name="restoring-transactions"></a>Восстановление транзакций

Когда `SKPaymentQueue.DefaultQueue.RestoreCompletedTransactions` является именем, комплект Store возвращает все предыдущие транзакции для пользователя. Если они приобрели большое число элементов или если у каждого из них имеются больших пакетов содержимого, восстановление приведет в большой объем сетевого трафика, как все, что получает из очереди для загрузки за один раз.

Рассмотрите возможность отслеживания ли продукт приобретается отдельно от фактической загрузки связанного содержимого пакета.

### <a name="pausing-restarting-and-canceling-downloads"></a>Приостановка, перезапуск и Отмена загрузки

Несмотря на то, что пример кода демонстрирует эту функцию, можно приостановить и перезапустить размещенной загрузки содержимого. `SKPaymentQueue.DefaultQueue` Имеет методы для `PauseDownloads`, `ResumeDownloads` и `CancelDownloads`.

Если код вызывает `FinishTransaction` в очередь оплаты до загрузки, `Finished` затем этого загруженного автоматически отменяется.

### <a name="setting-the-skip-backup-flag-on-the-downloaded-content"></a>Установка для флага SKIP-Backup на загруженное содержимое

Предложить правилам Apple в резервной копии iCloud, не написанный пользователем содержимое, которое легко восстанавливается на сервере нужно *не* быть резервных копий (так как его без необходимости использовать iCloud хранилища копий). Дополнительные сведения об установке атрибут резервного копирования, см. в разделе [файловая система](~/ios/app-fundamentals/file-system.md) документации.

## <a name="summary"></a>Сводка

В этой статье были представлены две новые функции комплекта Store iOS6: приобретение iTunes и другое содержимое в приложении и использование сервера Apple для размещения собственных покупки из приложений. В этом введении должны считываться в сочетании с существующим [документации покупки в приложении](~/ios/platform/in-app-purchasing/index.md) полный обзор реализации функциональности Store Kit.

## <a name="related-links"></a>Связанные ссылки

- [StoreKit (пример)](https://developer.xamarin.com/samples/StoreKit/)
- [Покупки из приложений](~/ios/platform/in-app-purchasing/index.md)
- [Ссылка на платформу StoreKit](https://developer.apple.com/library/prerelease/ios/#documentation/StoreKit/Reference/StoreKit_Collection/_index.html)
- [Ссылки на класс SKStoreProductViewController](https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKITunesProductViewController_Ref/SKStoreProductViewController.html)
- [Справочник по API поиска iTunes](http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html)
- [SKDownload](https://developer.apple.com/library/prerelease/ios/#documentation/StoreKit/Reference/SKDownload_Ref/Introduction/Introduction.html)
- [SKPaymentQueue](https://developer.apple.com/library/prerelease/ios/documentation/StoreKit/Reference/SKPaymentQueue_Class/Reference/Reference.html#/apple_ref/occ/instm/SKPaymentQueue/cancelDownloads:)
- [SKProduct](https://developer.apple.com/library/prerelease/ios/documentation/StoreKit/Reference/SKProduct_Reference/Reference/Reference.html#/apple_ref/occ/instp/SKProduct/downloadable)
- [Видео WWDC: Продажи продуктов с помощью комплекта Store](https://developer.apple.com/videos/wwdc/2012/?include=302#302)
