---
title: Тип регистратора для Xamarin.iOS
description: В этом документе описывается тип регистратора Xamarin.iOS, что делает C# классы, доступные в среде выполнения Objective-C.
ms.prod: xamarin
ms.assetid: 610A0834-1141-4D09-A05E-B7ADF99462C5
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 8/29/2018
ms.openlocfilehash: cd9e92e2c96d0a0696633e49869f2661e410d343
ms.sourcegitcommit: a1a58afea68912c79d16a3f64de9a0c1feb2aeb4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2019
ms.locfileid: "55233592"
---
# <a name="type-registrar-for-xamarinios"></a>Тип регистратора для Xamarin.iOS

В этом документе описывается система регистрации типов, используемых Xamarin.iOS.

## <a name="registration-of-managed-classes-and-methods"></a>Регистрация управляемых классов и методов

Во время запуска зарегистрирует Xamarin.iOS:

- Классы с [[регистрация]](xref:Foundation.RegisterAttribute) атрибут как классы Objective-C.
- Классы с [[категория]](xref:ObjCRuntime.CategoryAttribute) атрибут как Objective-C категории.
- Взаимодействует с [[Protocol]](xref:Foundation.ProtocolAttribute) атрибут как протоколы Objective-C.
- Члены с [[Экспорт]](xref:Foundation.ExportAttribute), отвечающим за Objective-C, для доступа к ним.

Например, рассмотрим управляемый `Main` метод, обычно в приложениях Xamarin.iOS:

```csharp
UIApplication.Main (args, null, "AppDelegate");
```

Этот код сообщает среде выполнения Objective-C для использования типа, названного `AppDelegate` как класс делегата приложения. Для создания экземпляра в среде выполнения Objective-C C# `AppDelegate` класса, что класс должен быть зарегистрирован.

Xamarin.iOS выполняет регистрацию автоматически, либо во время выполнения (динамическая регистрация), либо во время компиляции (статические регистрации).

Динамическая регистрация использует отражение, во время запуска, чтобы найти все классы и методы для регистрации, передавая их к среде выполнения Objective-C. Динамическая регистрация используется по умолчанию для сборок симулятора.

Во время компиляции статические регистрации проверка сборок, используемых приложением. Он определяет классы и методы для регистрации в Objective-C и создает карту, которая внедрена в двоичный файл.
Затем во время запуска, он регистрирует карты в среде выполнения Objective-C. Статические регистрации используется для сборок устройств.

### <a name="categories"></a>Категории

Начиная с Xamarin.iOS 8.10, имеется возможность создавать категории Objective-C с помощью C# синтаксис.

Чтобы создать категорию, используйте `[Category]` и укажите тип для расширения. Например, следующий код расширяет `NSString`:

```csharp
[Category (typeof (NSString))]
```

Каждый из методов категория имеет `[Export]` атрибут, делая его доступным в среде выполнения Objective-c.:

```csharp
[Export ("today")]
public static string Today ()
{
    return "Today";
}
```

Все методы управляемые расширения должны быть статическими, но можно создать методы экземпляра Objective-C с использованием стандарта C# синтаксис для методов расширения:

```csharp
[Export ("toUpper")]
public static string ToUpper (this NSString self)
{
    return self.ToString ().ToUpper ();
}
```

Первый аргумент к методу расширения — это экземпляр, для которого был вызван метод:

```csharp
[Category (typeof (NSString))]
public static class MyStringCategory
{
    [Export ("toUpper")]
    static string ToUpper (this NSString self)
    {
        return self.ToString ().ToUpper ();
    }
 }
 ```

Этот пример добавляет собственный `toUpper` метод для экземпляра `NSString` класса. Этот метод может вызываться из Objective-C:

```csharp
[Category (typeof (UIViewController))]
public static class MyViewControllerCategory
{
    [Export ("shouldAutoRotate")]
    static bool GlobalRotate ()
    {
        return true;
    }
}
```

### <a name="protocols"></a>Протоколы

Начиная с Xamarin.iOS 8.10, взаимодействует с `[Protocol]` атрибута будут экспортированы в Objective-C в качестве протоколов:

```csharp
[Protocol ("MyProtocol")]
interface IMyProtocol
{
    [Export ("method")]
    void Method ();
}

class MyClass : IMyProtocol
{
    void Method ()
    {
    }
}
```

Этот пример кода экспортирует `IMyProtocol` Objective-C, как протокол с именем `MyProtocol` и класс с именем `MyClass` , реализует протокол.

## <a name="new-registration-system"></a>Новая система регистрации

Начиная с 6.2.6 стабильной версии и бета-версию 6.3.4 версии, мы добавили новый статический регистратора доменных имен. В 7.2.1 версии, мы внесли новый регистратор по умолчанию.

Этой новой системы регистрации предлагает следующие новые функции:

- Обнаружение компиляции программист ошибок:
    - Два класса, регистрируемого с тем же именем.
    - Более одного метода, экспортировать реагировать на тот же селектор
- Удаление неиспользуемых машинного кода:
    - В новой системе регистрации добавит строгих ссылок на код, используемый в статических библиотеках, позволяя компоновщику убрать неиспользуемые машинного кода из результирующего двоичного файла. В привязках пример Xamarin большинство приложений становятся менее 300 КБ меньшего размера.

- Поддержка универсальных подклассы `NSObject`; см. в разделе [универсальные шаблоны NSObject](~/ios/internals/api-design/nsobject-generics.md) Дополнительные сведения. Кроме того, в новой системе регистрации будет перехватывать неподдерживаемый универсальные конструкции, которые бы ранее привело к непредвиденному поведению во время выполнения.

### <a name="errors-caught-by-the-new-registrar"></a>Ошибки, перехватываются новый регистратор

Ниже приведены некоторые примеры ошибок, перехватываются новый регистратор.

- Экспорт и тот же селектор более одного раза в одном классе:

    ```csharp
    [Register]
    class MyDemo : NSObject 
    {
        [Export ("foo:")]
        void Foo (NSString str);
        [Export ("foo:")]
        void Foo (string str)
    }
    ```

- Экспорт нескольких управляемый класс с тем же именем Objective-C:

    ```csharp
    [Register ("Class")]
    class MyClass : NSObject {}

    [Register ("Class")]
    class YourClass : NSObject {}
    ```

- Экспорт универсальных методов:

    ```csharp
    [Register]
    class MyDemo : NSObject
    {
        [Export ("foo")]
        void Foo<T> () {}
    }
    ```

### <a name="limitations-of-the-new-registrar"></a>Ограничения новый регистратор

Некоторые особенности, которые следует учитывать новый регистратор:

- Необходимо обновить некоторые сторонние библиотеки для работы с новой системой регистрации. См. в разделе [необходимые изменения](#required_modifications) ниже для получения дополнительных сведений.

- Краткосрочной недостатком является также, что Clang необходимо использовать, если используется платформа учетных записей (это обусловлено Apple **accounts.h** заголовка может быть скомпилированы только с Clang). Добавить `--compiler:clang` к дополнительным аргументам mtouch использовать Clang, если вы используете Xcode 4.6 или более ранней версии (Xamarin.iOS будет автоматически выбирать Clang в Xcode 5.0 или более поздней версии).

- Если Xcode 4.6 (или более ранней версии) используется, GCC / G ++ должен быть выбран, если экспортируемого типа имена содержат отличные от ASCII символы, (это потому, что версия Clang поставляется с Xcode 4.6 поддерживает отличные от ASCII символы внутри идентификаторы в коде Objective-C). Добавить `--compiler:gcc` к дополнительным аргументам mtouch использовать GCC.

## <a name="selecting-a-registrar"></a>Выбор регистратора доменных имен

Можно выбрать другой регистратора доменных имен, добавив один из следующих вариантов дополнительным аргументам mtouch в проекте **сборка iOS** параметры:

- `--registrar:static` — по умолчанию для сборок устройств
- `--registrar:dynamic` — по умолчанию для сборок симулятора

> [!NOTE]
> Классический API Xamarin поддерживается другие параметры, такие как `--registrar:legacystatic` и `--registrar:legacydynamic`. Тем не менее эти параметры не поддерживаются на единый API.

## <a name="shortcomings-in-the-old-registration-system"></a>Недостатки в старую систему регистрации

Старая система регистрации имеет следующие недостатки:

- Возникла не (собственной) статическую ссылку на Objective-C классов и методов в собственные библиотеки независимых производителей, которые означало, что мы не просим компоновщику удаление сторонних машинного кода, который не был фактически используется (поскольку все, что будут удалены). Это является причиной `-force_load libNative.a` , каждая привязка независимых производителей было нужно (или эквивалент `ForceLoad=true` в `[LinkWith]` атрибут).
- Можно экспортировать двумя управляемых типов с одинаковым именем Objective-C без предупреждения. Редко требовалось в итоге с двумя `AppDelegate` классы в разных пространствах имен. Во время выполнения было бы полностью произвольным какой из них было выбрано (фактически, из-за разнообразными между запусками приложения, которое еще не был перестроен - которого для очень замешательство и нервов процесс отладки).
- Можно экспортировать два метода с одинаковыми сигнатурами Objective-C. До сих пор случайна какой из них будет вызываться из Objective-C (но эта проблема не была так часто, что и предыдущий, главным образом потому, что единственным способом фактически возникнуть эта ошибка была переопределить метод повезет управляемого).
- Набор методов, который был экспортирован был немного отличается в динамических и статических сборок.
- Он не работает должным образом, при экспорте универсальные классы (какие конкретно универсального выполняется во время выполнения будет случайным образом позволяет получить неопределенное поведение).

## <a name="new-registrar-required-changes-to-bindings"></a>Новый регистратор: необходимо изменение привязок

В этом разделе описываются изменения привязок, которые должны выполняться для работы с помощью нового регистратора.

### <a name="protocols-must-have-the-protocol-attribute"></a>Протоколы должен иметь атрибут [Protocol]

Протоколы требует наличия `[Protocol]` атрибута. Если этого не сделать, вы научитесь ошибка собственного компоновщика, такие как:

```console
Undefined symbols for architecture i386: "_OBJC_CLASS_$_ProtocolName", referenced from: ...
```

### <a name="selectors-must-have-a-valid-number-of-parameters"></a>Селекторы должен иметь допустимое число параметров

Все селекторы необходимо правильно указать число параметров. Ранее эти ошибки были пропущены и может вызвать проблемы среды выполнения.

Короче говоря количество двоеточий должны совпадать с числом параметров:

- Без параметров: `foo`
- Один параметр: `foo:`
- Два параметра: `foo:parameterName2:`

Ниже приведены неправильные использует.

```csharp
// Invalid: export takes no arguments, but function expects one
[Export ("apply")]
void Apply (NSObject target);

// Invalid: exported as taking an argument, but the managed version does not have one:
[Export ("display:")]
void Display ();
```

### <a name="use-isvariadic-parameter-in-export"></a>Используйте параметр IsVariadic в экспорте

Необходимо использовать функции с переменным числом аргументов `IsVariadic` аргумент `[Export]` атрибут:

```csharp
[Export ("variadicMethod:", IsVariadic = true)]
void VariadicMethod (NSObject first, IntPtr subsequent);
```

### <a name="must-link-to-existing-symbols"></a>Необходимо связать существующие символы

Вы не сможете привязать классы, которые не существуют в собственной библиотеки.
Если класс был удален из или переименовано в собственной библиотеки, не забудьте обновить привязки в соответствии с.
