---
title: CloudKit в Xamarin.iOS
description: В этом документе описывается, как работать с CloudKit в Xamarin.iOS. Он представлен обзор CloudKit и обсуждаются способы включить его, CloudKit удобства API, масштабируемость, учетные записи пользователей и разработки и рабочей среде.
ms.prod: xamarin
ms.assetid: 66B207F2-FAA0-4551-B43B-3DB9F620C397
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 05/11/2016
ms.openlocfilehash: daea27472ac7c0578c1cfd79ebd96428212fafb3
ms.sourcegitcommit: e268fd44422d0bbc7c944a678e2cc633a0493122
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "50107447"
---
# <a name="cloudkit-in-xamarinios"></a>CloudKit в Xamarin.iOS

Инфраструктура CloudKit упрощает разработку приложений, доступа к iCloud. Сюда входят методы для получения данных приложений и средств права, а также возможность обеспечить безопасное хранение сведений о приложении. Этот комплект предоставляет пользователям уровня анонимности, разрешив доступ к приложениям с их iCloud идентификаторы без обмена личными данными.

Разработчики могут сосредоточиться на своих клиентских приложений и позволить iCloud полностью устранить необходимость создавать логику приложения на стороне сервера. CloudKit предоставляет проверку подлинности, частных и общедоступных баз данных и структурированных данных и ресурс службы хранилища.

> [!IMPORTANT]
> Компания Apple [предоставляет инструменты](https://developer.apple.com/support/allowing-users-to-manage-data/), которые помогают разработчикам надлежащим образом соблюдать Общий регламент по защите данных Европейского союза (GDPR).

## <a name="requirements"></a>Требования

Чтобы завершить действия, описанные в этой статье требуется следующее:

-  **Xcode и пакет SDK iOS** — Apple Xcode и iOS 8 API-интерфейсы должны быть установлен и настроен на компьютере разработчика.
-  **Visual Studio для Mac** — последнюю версию Visual Studio для Mac должны быть установлены и настроены на устройстве пользователя.
-  **iOS 8 устройства** — устройства iOS под управлением последней версии iOS 8 для тестирования.

## <a name="what-is-cloudkit"></a>Что такое CloudKit

CloudKit — это способ предоставить разработчику доступ к iCloud серверов. Он предоставляет основу для iCloud Drive и использовать Медиатеку iCloud. CloudKit поддерживается для устройств с Mac OS X и Apple iOS.

 [![](intro-to-cloudkit-images/image1.png "Как CloudKit поддерживается на устройствах Apple iOS и Mac OS X")](intro-to-cloudkit-images/image1.png#lightbox)

CloudKit использует инфраструктуру учетной записи iCloud. Если пользователь, вошедший в iCloud запись на устройстве, CloudKit будет использовать их идентификатор для идентификации пользователя. Если учетная запись отсутствует, будет предоставлен ограниченный доступ только для чтения.

CloudKit поддерживает концепцию общедоступных и частных баз данных. Открытый базы данных предоставляют «soup» всех данных, к которым пользователь имеет доступ к. Закрытый базы данных предназначены для хранения личных данных, привязанного к конкретному пользователю.

CloudKit поддерживает как структурированные, так и массовом данные. Это может легко обрабатывать файлы большого размера. CloudKit берет на себя эффективной передачи больших файлов и из iCloud серверы в фоновом режиме, освобождая разработчика для работы над другими задачами.

> [!NOTE]
> Важно отметить, что CloudKit _технология_. Она не предоставляет хранилища; Она только позволяет приложению отправлять и получать сведения с серверов, эффективно.

На момент написания этой статьи, Apple, изначально обеспечивает CloudKit бесплатно с высокий предел емкости, пропускной способности и хранилища. Для больших проектов или приложений с помощью больших потерях Apple управляемая будет предоставляться масштабе ценообразования по доступной цене.


## <a name="enabling-cloudkit-in-a-xamarin-application"></a>Включение CloudKit в приложении Xamarin

Прежде чем приложения Xamarin можно использовать в CloudKit Framework, приложения должны быть правильно подготовлены как описано в [работа с возможностями](~/ios/deploy-test/provisioning/capabilities/icloud-capabilities.md) и [работа с назначениями](~/ios/deploy-test/provisioning/entitlements.md) направляющие

1.  Откройте проект в Visual Studio для Mac или Visual Studio.
2.  В **обозревателе решений**откройте **Info.plist** файл и убедитесь, **идентификатор пакета** соответствует типу, который был определен в **идентификатор приложения**создан как часть подготовки настроить:
 
    [![](intro-to-cloudkit-images/image26a.png "Введите идентификатор пакета")](intro-to-cloudkit-images/image26a-orig.png#lightbox "Info.plist file displaying Bundle Identifier")

3.  Прокрутите вниз до нижней части **Info.plist** файл и выберите **включить фоновые режимы**, **обновления расположения** и **удаленные уведомления**:

    [![](intro-to-cloudkit-images/image27a.png "Выберите Включить фоновые режимы, расположение обновлений, а также удаленные уведомления")](intro-to-cloudkit-images/image27a-orig.png#lightbox "Info.plist file displaying background modes")
4.  Щелкните правой кнопкой мыши проект iOS в решение и выберите **параметры**.
5.  Выберите **подписывание пакета iOS**выберите **Developer Identity** и **профиль подготовки** созданной выше.
6.  Убедитесь, **Entitlements.plist** включает в себя **включить iCloud** , **хранилище ключ значение** и **CloudKit** .
7.  Убедитесь, **контейнера распространенность** существует для приложения (как созданной ранее). Пример: `iCloud.com.your-company.CloudKitAtlas`
8.  Сохраните изменения в файле.


Эти параметры заданы приложение теперь может получить доступ к API-интерфейсы CloudKit Framework.

## <a name="cloudkit-api-overview"></a>Общие сведения об API CloudKit

Перед реализацией CloudKit в приложении Xamarin iOS, будет в этой статье рассматриваются основы в CloudKit платформу, которая будет включать следующие разделы:

1.  **Контейнеры** — изолированная приемники команд iCloud связи.
2.  **Базы данных** — общедоступных и частных доступны для приложения.
3.  **Записи** — механизм, в котором перемещается структурированных данных, а из CloudKit.
4.  **Запись зоны** — это группы записи.
5.  **Запишите идентификаторы** — полностью нормализуются и представляют конкретное расположение записи.
6.  **Справочник по** — предоставляют иерархические отношения между записями в пределах заданной базы данных.
7.  **Активы** — разрешить файлу больших, неструктурированных данных с iCloud и связанные с определенной записи.


### <a name="containers"></a>Контейнеры

Данного приложения, запущенного на устройстве iOS всегда работает вместе стороны других приложений и служб на этом устройстве. На клиентском устройстве приложение будет бессистемного или изолированной каким-либо образом. В некоторых случаях это литерал "песочницу", а в других случаях, оно будет просто работают в его собственной памяти.

Концепция создания клиентского приложения с последующим запуском отделены от других клиентов — очень мощный инструмент и обеспечивает следующие преимущества:

1.  **Безопасность** — одно приложение не оказывает влияния на другие клиентские приложения или самой ОС.
1.  **Стабильность** — в случае сбоя клиентского приложения, она не может вывести из других приложений операционной системы.
1.  **Конфиденциальность** — каждое клиентское приложение имеет ограниченный доступ к личной информации, хранимой в пределах устройства.


CloudKit было введено для предоставляют те же преимущества, как указанные выше и применить их к работе с информацией на основе облака:

 [![](intro-to-cloudkit-images/image31.png "Приложения, CloudKit взаимодействовать с помощью контейнеров")](intro-to-cloudkit-images/image31.png#lightbox)

Так же, как приложение, находящееся в один из многих работает на устройстве, так это связь приложения с iCloud один из многих. Каждый из этих хранилищах взаимодействия, называются контейнерами.

Контейнеры, представлены в CloudKit Framework через `CKContainer` класса. По умолчанию одно приложение взаимодействует с одного контейнера и этот контейнер отделяющее данных для этого приложения. Это означает, что несколько приложений могут хранить сведения для одной и той же учетной записи iCloud, но эта информация вставлять никогда не можно.

Создание контейнеров данных iCloud позволяет CloudKit для инкапсуляции сведений о пользователе. В этом случае приложение будет иметь некоторые ограниченный доступ к учетной записи iCloud и данные пользователя, которые хранятся в то же время, по-прежнему защиты конфиденциальности и безопасности пользователя.

Контейнеры полностью управляются разработчиком приложения с помощью портала WWDR. Пространство имен контейнера является глобальным для всех разработчиков Apple, чтобы контейнер должен не только быть уникальным для данного разработчика приложений, но для всех разработчиков Apple и приложений.

Apple предлагает, использовать обратную нотацию DNS, при создании пространства имен для контейнеров приложений. Пример

```csharp
iCloud.com.company-name.application-name
```

Хотя контейнеры являются, по умолчанию, привязанного один к одному конкретному приложению, они могут быть общими для приложений. Поэтому в одном контейнере может координировать несколько приложений. Одно приложение может также взаимодействовать с несколько контейнеров.

### <a name="databases"></a>Databases

Одним из основных функций CloudKit является к модели данных приложения и репликации эту модель до серверов iCloud. Некоторые сведения предназначены для пользователя, который его создал, остальные данные являются общих данных, которая может возникнуть пользователем для открытого использования (например, ресторане) или это может быть сведения, которые опубликованы разработчик приложения. В любом случае аудитории не только один пользователь, но является сообщество пользователей.

 [![](intro-to-cloudkit-images/image32.png "Схема контейнера CloudKit")](intro-to-cloudkit-images/image32.png#lightbox)

Внутри контейнера в первую очередь является общей базы данных. Это, где все сведения об открытых располагается и совместно mingles. Кроме того существует несколько отдельных частных базах данных для каждого пользователя приложения.

При запуске на устройстве iOS приложения получат доступ только к информации для пользователя, вошедшего в iCloud. Так что представления приложения контейнера будет иметь следующий вид:

 [![](intro-to-cloudkit-images/image33.png "Представление приложений контейнера")](intro-to-cloudkit-images/image33.png#lightbox)

Его можно только см. в разделе базы данных общих и частных базы данных, связанной с iCloud вошедшего в систему пользователя.

Базы данных предоставляются в CloudKit Framework через `CKDatabase` класса. Каждое приложение имеет доступ к две базы данных: базы данных public и один закрытый.

Контейнер является начальной отправной точкой в CloudKit. Для доступа к базе данных общедоступных и частных из приложения по умолчанию контейнера можно использовать следующий код:

```csharp
using CloudKit;
...

public CKDatabase PublicDatabase { get; set; }
public CKDatabase PrivateDatabase { get; set; }
...

// Get the default public and private databases for
// the application
PublicDatabase = CKContainer.DefaultContainer.PublicCloudDatabase;
PrivateDatabase = CKContainer.DefaultContainer.PrivateCloudDatabase;
```

Ниже приведены различия между типами базы данных.

||Базы данных Public|Личная база данных|
|---|--- |--- |
|**Тип данных**|Общие данные|Данные текущего пользователя|
|**Квота**|Учитываются в квоте разработчика|Учитываются в квоте пользователя|
|**Разрешения по умолчанию**|Мир для чтения|Пользователь для чтения|
|**Изменение разрешений**|iCloud панели мониторинга ролей через уровень класса записи|Н/Д|

### <a name="records"></a>Записи

Контейнеры размещения баз данных и внутри базы данных являются записями. Записи представляют собой механизм, в котором перемещается структурированных данных, а из CloudKit:

 [![](intro-to-cloudkit-images/image34.png "Контейнеры размещения баз данных и внутри базы данных являются записями")](intro-to-cloudkit-images/image34.png#lightbox)

Записи, представлены в CloudKit Framework через `CKRecord` класс, который создает оболочку для пары "ключ значение". Экземпляр объекта в приложении эквивалентно `CKRecord` в CloudKit. Кроме того каждый `CKRecord` обладающий типом записи, что эквивалентно классу объекта.

Записи имеют схему just-in-time, поэтому данные описываются в CloudKit перед передан для обработки. С этого момента CloudKit будет интерпретировать эти данные и обрабатывать материально-технического обеспечения хранения и извлечения записи.

`CKRecord` Класс также поддерживает широкий спектр метаданных. Например запись содержит сведения о его создания и пользователь, создавший его. Запись также содержит сведения о его изменения и пользователем, который изменил его.

Записи содержат понятие тег изменений. Это предыдущую версию данной записи версии. Изменение тега используется в качестве недоступно: возможность определения того, если клиент и сервер имеют ту же версию данной записи.

Как уже говорилось, `CKRecords` wrap пары "ключ значение", и таким образом, следующие типы данных могут храниться в записи:

1.   `NSString`
1.   `NSNumber`
1.   `NSData`
1.   `NSDate`
1.   `CLLocation`
1.   `CKReferences`
1.   `CKAssets`


В дополнение к типам одно значение запись может содержать однородные массив любого из перечисленных выше типов.

Чтобы создать новую запись и сохранить ее в базу данных можно использовать следующий код:

```csharp
using CloudKit;
...

private const string ReferenceItemRecordName = "ReferenceItems";
...

var newRecord = new CKRecord (ReferenceItemRecordName);
newRecord ["name"] = (NSString)nameTextField.Text;
await CloudManager.SaveAsync (newRecord);
```

### <a name="record-zones"></a>Записи зоны

Сами по себе не существуют записи в пределах заданной базы данных — вместе существуют группы записей в зоне записи. Запись зоны может рассматриваться как таблиц в традиционных реляционных баз данных:

 [![](intro-to-cloudkit-images/image35.png "Набор записей существует друг с другом в зоне записи")](intro-to-cloudkit-images/image35.png#lightbox)

Может существовать несколько записей в конкретной зоне записи и нескольких зонах записей в пределах заданной базы данных. Каждая база данных содержит записи зоны по умолчанию:

 [![](intro-to-cloudkit-images/image36.png "Каждая база данных содержит записи зоны по умолчанию и пользовательские зоны")](intro-to-cloudkit-images/image36.png#lightbox)

Это, где хранятся записи по умолчанию. Кроме того можно создавать настраиваемые записи зоны. Базовый гранулярности, на какие механизма атомарных операций фиксации и отслеживания изменений выполняется представляют записи зоны.

## <a name="record-identifiers"></a>Идентификаторы записи

Запись идентификаторы представляются в виде кортежа, содержащее методы клиент получает имя записи и зону, в которой существует запись. Идентификаторы записи имеют следующие характеристики:

-  Они создаются в клиентском приложении.
-  Они полностью нормализуются и представляют конкретное расположение записи.
-  Назначая уникальный идентификатор записи в базу данных внешнего имени записи, они могут использоваться моста для локальных баз данных, которые больше не будут сохранены в CloudKit.


Если разработчик создает новые записи, можно передать идентификатор записи. Если не указан идентификатор записи, UUID будет автоматически создается и назначается записи.

Если разработчик создает новые идентификаторы записи, можно указать записи зоны, каждая запись будет принадлежать. Если ничего не указано, будет использоваться запись зоны по умолчанию.

Идентификаторы записи, представлены в CloudKit Framework через `CKRecordID` класса. Чтобы создать новый идентификатор записи можно использовать следующий код:

```csharp
var recordID =  new CKRecordID("My Record");
```

### <a name="references"></a>Ссылки

Ссылки предоставляют отношения между записями в пределах заданной базы данных:

 [![](intro-to-cloudkit-images/image37.png "Ссылки предоставляют отношения между записями в пределах заданной базы данных.")](intro-to-cloudkit-images/image37.png#lightbox)

В приведенном выше примере родительских элементов принадлежат дочерние элементы, таким образом, чтобы дочерний элемент является дочерней записи родительской записи. Связь переходит из дочерней записи родительской записи и называется *обратно ссылку*.

Ссылки, представлены в CloudKit Framework через `CKReference` класса. Они предназначены для того, позволяющий серверу iCloud понимать связь между записями.

Ссылки обеспечивают механизм за каскадное удаление. Если родительскую запись удаляется из базы данных, все дочерние записи (как указано в отношении) будут автоматически удалены из базы данных также.

> [!NOTE]
> Несвязанные указатели являются вероятность того, при помощи CloudKit. Например когда приложение извлечь список записей указателей, выбирает запись и затем запросить для записи, запись уже не существует в базе данных. Приложения должны быть реализованы для корректной обработки этой ситуации.

Не обязательно, обратно ссылки являются предпочтительными при работе с платформой CloudKit. Apple точно настраивать системы, чтобы сделать это наиболее эффективный тип ссылки.

При создании ссылки, разработчик можно указать запись, которая уже находится в памяти или создать ссылку на идентификатор записи. Если с помощью идентификатора записи и указанной ссылки не существует в базе данных, будут создаваться указатель висячего.

Ниже приведен пример создания ссылки от известных записи:

```csharp
var reference = new CKReference(newRecord, new CKReferenceAction());
```

### <a name="assets"></a>Ресурсы

Активы разрешить для файла данных большой, неструктурированные данные с iCloud и связанные с определенной записи:

 [![](intro-to-cloudkit-images/image38.png "Разрешить средства для файла данных большой, неструктурированные данные с iCloud и связанные с определенной записи")](intro-to-cloudkit-images/image38.png#lightbox)

На стороне клиента `CKRecord` создается, описывающий файл, который будет отправляться на сервер iCloud. Объект `CKAsset` создается в файле и связанного с записью, сведениями о нем.

При отправке файла на сервер, запись помещается в базе данных и файл копируется в это специальная база данных хранилища Bulk. Создается связь между записью указателя и отправленного файла.

Ресурсы предоставляются в CloudKit Framework через `CKAsset` класса и используются для хранения больших, неструктурированных данных. Так как разработчику не требуется большой, неструктурированных данных в памяти, ресурсов реализуются с помощью файлов на диске.

Активы, принадлежат записи, которые позволяет активы с iCloud, используя запись как указатель. В этом случае сервер можно средств сбора мусора, при удалении записи, которой принадлежит ресурс.

Так как `CKAssets` предназначены обрабатывать большие файлы данных, Apple предназначен CloudKit эффективно отправлять и загружать ресурсы.

Чтобы создать актив и связать его с записью можно использовать следующий код:

```csharp
var fileUrl = new NSUrl("LargeFile.mov");
var asset = new CKAsset(fileUrl);
newRecord ["name"] = asset;
```

Мы теперь рассмотрели все основные объекты в CloudKit. Контейнеры связаны с приложениями и содержать баз данных. Базы данных содержат записи, которые группируются в записи зоны и указывает идентификаторы записи. Иерархические отношения определяются между записями с помощью ссылки. Наконец можно передать и связанных записей с помощью средств больших файлов.

## <a name="cloudkit-convenience-api"></a>CloudKit удобный API

Apple предлагает два разных набора API для работы с CloudKit:

-  **API в службе Operational** — предлагает каждый отдельный компонент CloudKit. Для более сложных приложений этот API предоставляет возможность точного управления CloudKit.
-  **Удобный API** — включает некоторые распространенные, предварительно настроенных CloudKit функции. Он обеспечивает удобный и простой доступ решение для включая CloudKit функциональность в приложении iOS.


API удобства обычно отлично подходит для большинства приложений iOS и Apple предлагает, начиная с ним. В оставшейся части этого раздела рассматривается в следующих разделах удобства API:

-  Сохранение записи.
-  Извлечение записи.
-  Обновление записи.


### <a name="common-setup-code"></a>Общий код установки

Перед началом работы с API удобства CloudKit есть необходимый код стандартной установки. Начать с изменения приложения `AppDelegate.cs` файл и это должно выглядеть следующим образом:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Foundation;
using UIKit;
using CloudKit;

namespace CloudKitAtlas
{
    [Register ("AppDelegate")]
    public partial class AppDelegate : UIApplicationDelegate
    {
        #region Computed Properties
        public override UIWindow Window { get; set;}
        public CKDatabase PublicDatabase { get; set; }
        public CKDatabase PrivateDatabase { get; set; }
        #endregion

        #region Override Methods
        public override bool FinishedLaunching (UIApplication application, NSDictionary launchOptions)
        {
            application.RegisterForRemoteNotifications ();

            // Get the default public and private databases for
            // the application
            PublicDatabase = CKContainer.DefaultContainer.PublicCloudDatabase;
            PrivateDatabase = CKContainer.DefaultContainer.PrivateCloudDatabase;

            return true;
        }

        public override void RegisteredForRemoteNotifications (UIApplication application, NSData deviceToken)
        {
            Console.WriteLine ("Registered for Push notifications with token: {0}", deviceToken);
        }

        public override void FailedToRegisterForRemoteNotifications (UIApplication application, NSError error)
        {
            Console.WriteLine ("Push subscription failed");
        }

        public override void ReceivedRemoteNotification (UIApplication application, NSDictionary userInfo)
        {
            Console.WriteLine ("Push received");
        }
        #endregion
    }
}
```

Приведенный выше код предоставляет общедоступные и частные CloudKit баз данных в виде сочетания клавиш, чтобы облегчить их для работы в остальной части приложения.

Добавьте следующий код в любое представление или контейнер представления, которые будут использовать CloudKit:

```csharp
using CloudKit;
...

#region Computed Properties
public AppDelegate ThisApp {
    get { return (AppDelegate)UIApplication.SharedApplication.Delegate; }
}
#endregion
```

Это добавляет ярлык для получения `AppDelegate` и получить доступ к клавиш общедоступных и частных базы данных, созданной ранее.

Этот код в месте давайте рассмотрим реализация API удобства CloudKit в приложении Xamarin iOS 8.

### <a name="saving-a-record"></a>Сохранение записи

При использовании шаблона, представленные выше при обсуждении записей следующий код будет создать новую запись и использовать API удобства сохранить его общей базы данных:

```csharp
private const string ReferenceItemRecordName = "ReferenceItems";
...

// Create a new record
var newRecord = new CKRecord (ReferenceItemRecordName);
newRecord ["name"] = (NSString)nameTextField.Text;

// Save it to the database
ThisApp.PublicDatabase.SaveRecord(newRecord, (record, err) => {
    // Was there an error?
    if (err != null) {
        ...
    }
});
```

Три замечаний относительно приведенный выше код:

1.  Путем вызова `SaveRecord` метод `PublicDatabase`, разработчик не должна указывать, каким образом данные отправляются, какой зоны, он записывается в и т. д. API удобства принципиально все эти сведения о самой.
1.  Вызов является асинхронным и предоставляет программу ответного вызова после завершения вызова, либо с помощью об успехе или неудаче. Если вызов завершается сбоем, сообщение об ошибке будет предоставляться.
1.  CloudKit не поддерживает хранилище и сохранять данные локально; Это только среду передачи. Поэтому при запросе сохранить запись, немедленно отправкой на серверы iCloud.


> [!NOTE]
> Из-за «» вероятны communications мобильной сети, где соединений постоянно, удаляются или прервана, один из первой рекомендации, которые разработчик должен выполнить при работе с CloudKit обработки ошибок.

### <a name="fetching-a-record"></a>Получение записи

С помощью записи создаются и успешно хранятся на сервере iCloud используйте следующий код для извлечения записи:

```csharp
// Create a record ID and fetch the record from the database
var recordID = new CKRecordID("MyRecordName");
ThisApp.PublicDatabase.FetchRecord(recordID, (record, err) => {
    // Was there an error?
    if (err != null) {
        ...
    }
});
```

Так же, как показано сохранение записи, приведенный выше код асинхронные, простой и требует обработки отличный ошибок.

### <a name="updating-a-record"></a>Обновление записи

После записи были получены с серверов iCloud, измените запись и сохраните изменения в базе данных можно использовать следующий код:

```csharp
// Create a record ID and fetch the record from the database
var recordID = new CKRecordID("MyRecordName");
ThisApp.PublicDatabase.FetchRecord(recordID, (record, err) => {
    // Was there an error?
    if (err != null) {

    } else {
        // Modify the record
        record["name"] = (NSString)"New Name";

        // Save changes to database
        ThisApp.PublicDatabase.SaveRecord(record, (r, e) => {
            // Was there an error?
            if (e != null) {
                 ...
            }
        });
    }
});
```

`FetchRecord` Метод `PublicDatabase` возвращает `CKRecord` Если вызов был успешным. Затем приложение изменяет записи и вызывает `SaveRecord` еще раз, чтобы записать изменения обратно в базу данных.

В этом разделе показано типичный цикл, что приложение будет использовать при работе с API удобства CloudKit. Приложение сохранит записи iCloud, извлечение этих записей из iCloud, измените записи и сохранить эти изменения обратно в iCloud.

## <a name="designing-for-scalability"></a>Проектирование для масштабируемости

До сих в этой статье пользователя хранения и извлечения вся объектная модель приложения с iCloud серверов, каждый раз, он будет работать. Хотя этот подход хорошо работает с небольшой объем данных и очень мало базы пользователей, он плохо масштабируются при объем информации или пользователя базового увеличивается.

### <a name="big-data-tiny-device"></a>Большие наборы данных, мало места устройства

Другие популярные приложения становится, чем больше данных в базе данных и тем менее нецелесообразно, является использование кэша, все данные на устройстве. Чтобы устранить эту проблему, можно использовать следующие методы:

-  **Хранить большие объемы данных в облаке** — CloudKit была разработана для эффективной обработки больших объемов данных.
-  **Клиент следует просматривать только срез данных** — отказу минимальные данные, необходимые для обработки любой задачи в определенный момент времени.
-  **Можно изменить представления клиентов** — поскольку каждый пользователь имеет различные предпочтения, срез данных можно изменить для всех пользователей и пользователей с отдельных представлением любого заданного среза может быть различным.
-  **Клиент использует запросы сосредоточиться точки зрения** — запросы позволяют пользователю просматривать небольшое подмножество набора данных большего размера, который существует в облаке.


### <a name="queries"></a>Запросы

Как уже говорилось, запросы позволяют разработчику выбрать небольшое подмножество большего набора данных, который существует в облаке. Запросы, представлены в CloudKit Framework через `CKQuery` класса.

Запрос объединяет три разные вещи: тип записи ( `RecordType`), предикат ( `NSPredicate`) и, при необходимости дескриптора сортировки ( `NSSortDescriptors`). CloudKit поддерживает большинство `NSPredicate`.

#### <a name="supported-predicates"></a>Поддерживаемые предикатов

CloudKit поддерживает следующие типы `NSPredicates` при работе с запросами:


1. Подходящие записи, где имя — значения, хранящегося в переменной:
    
    ```
    NSPredicate.FromFormat(string.Format("name = '{0}'", recordName))
    ```
   
2. Позволяет сопоставления должен быть основан на динамическое значение ключа, таким образом, чтобы ключ не должен быть известен во время компиляции:
    
    ```
    NSPredicate.FromFormat(string.Format("{0} = '{1}'", key, value))
    ```
    
3. Подходящие записи, где значение записи больше заданного значения:
   
    ```
    NSPredicate.FromFormat(string.Format("start > {0}", (NSDate)date))
    ```

4. Подходящие записи, где записи расположения — в 100 метров, из заданного расположения:
    
    ```
    var location = new CLLocation(37.783,-122.404);
    var predicate = NSPredicate.FromFormat(string.Format("distanceToLocation:fromLocation(Location,{0}) < 100", location));
    ```

5. CloudKit поддерживает токенами поиск. Этот вызов создает два маркера, один для `after` , а другой для `session`. Он возвращает запись, которая содержит эти два маркера:
    
    ```
    NSPredicate.FromFormat(string.Format("ALL tokenize({0}, 'Cdl') IN allTokens", "after session"))
    ```
    
 6. Поддерживает CloudKit составные предикаты, соединенные `AND` оператор.
    
    ```
    NSPredicate.FromFormat(string.Format("start > {0} AND name = '{1}'", (NSDate)date, recordName))
    ```
    


#### <a name="creating-queries"></a>Создание запросов

Следующий код может использоваться для создания `CKQuery` в приложении Xamarin iOS 8:

```csharp
var recordName = "MyRec";
var predicate = NSPredicate.FromFormat(string.Format("name = '{0}'", recordName));
var query = new CKQuery("CloudRecords", predicate);
```

Во-первых он создает предикат для выбора только те записи, совпадающие с заданным именем. Затем он создает запрос, который будет выбирать записи данного типа записи, соответствующие предикату.

#### <a name="performing-a-query"></a>Выполнение запроса

После создания запроса, используйте следующий код для выполнения запроса и обработки возвращаемых записей:

```csharp
var recordName = "MyRec";
var predicate = NSPredicate.FromFormat(string.Format("name = {0}", recordName));
var query = new CKQuery("CloudRecords", predicate);

ThisApp.PublicDatabase.PerformQuery(query, CKRecordZone.DefaultRecordZone().ZoneId, (NSArray results, NSError err) => {
    // Was there an error?
    if (err != null) {
       ...
    } else {
        // Process the returned records
        for(nint i = 0; i < results.Count; ++i) {
            var record = (CKRecord)results[i];
        }
    }
});
```

Приведенный выше код принимает запрос, созданный выше и выполняет ее в общей базе данных. Так как зона запись не указана, производится поиск всех зон. Если ошибок нет, массив `CKRecords` будет возвращаться совпадающих с параметрами запроса.

Способ задуматься о запросах — что они являются опросы и отлично Фрагментирование через больших наборов данных. Запросы, тем не менее, не очень хорошо подходят для больших, чаще всего статические наборы данных из-за следующих причин:

-  Они плохо сказывается на срок службы аккумулятора устройства.
-  Они плохо для сетевого трафика.
-  Они плохо сказывается на взаимодействие с пользователем, так как сведения, которые они видят ограничен, как часто приложение опрашивает базу данных. Сегодня пользователи ожидают Push-уведомлений, при каких-либо изменений.


### <a name="subscriptions"></a>Подписки

При работе с большой, чаще всего статические наборы данных, запрос не следует выполнять на клиентском устройстве, он должен выполняться на сервере от имени клиента. Запрос должен выполняться в фоновом режиме и будет выполнена после сохранения каждой отдельной записи, с текущего устройства или другое устройство, если выбрать ту же базу данных.

Наконец Push-уведомления должны отправляться каждые устройство, подключенное к базе данных, при выполнении запросов на сервере.

Подписки, представлены в CloudKit Framework через `CKSubscription` класса. Тип записи в них сочетаются ( `RecordType`), предикат ( `NSPredicate`) и Push-уведомлений Apple ( `Push`).

> [!NOTE]
> CloudKit Push-уведомлений немного дополняются, так как они содержат полезные данные, содержащий CloudKit подробную информацию, например, что вызвало Push-уведомления произойдет.

#### <a name="how-subscriptions-work"></a>Как работают подписок

Перед реализацией подписки в C# кода, давайте рассмотрим краткий обзор принципов работы подписок:

 [![](intro-to-cloudkit-images/image39.png "Обзор принципов работы подписок")](intro-to-cloudkit-images/image39.png#lightbox)

Выше диаграмме показан процесс обычной подписке следующим образом:

1.  Клиентское устройство создает новую подписку, содержащую набор условий, которые будут активировать подписку и Push-уведомлений, которое будет отправляться, когда триггер срабатывает.
2.  Подписки отправляется в базу данных, где он добавляется в коллекцию существующих подписок.
3.  Второе устройство создает новую запись и сохраняет эту запись в базу данных.
4.  Базы данных выполняет поиск по списку подписок, соответствует ли новой записи любого из своих условий.
5.  Если соответствие найдено, Push-уведомлений отправляется на устройство, которое зарегистрировано сведения о записи, вызвавшей его, чтобы активировать подписку.


С этими сведениями на месте давайте взглянем на создание подписок в Xamarin iOS 8 приложения.

#### <a name="creating-subscriptions"></a>Создание подписок

Для создания подписки можно использовать следующий код:

```csharp
// Create a new subscription
DateTime date;
var predicate = NSPredicate.FromFormat(string.Format("start > {0}", (NSDate)date));
var subscription = new CKSubscription("RecordType", predicate, CKSubscriptionOptions.FiresOnRecordCreation);

// Describe the type of notification
var notificationInfo = new CKNotificationInfo();
notificationInfo.AlertLocalizationKey = "LOCAL_NOTIFICATION_KEY";
notificationInfo.SoundName = "ping.aiff";
notificationInfo.ShouldBadge = true;

// Attach the notification info to the subscription
subscription.NotificationInfo = notificationInfo;
```

Во-первых он создает предикат, который предоставляет условие для активации подписки. Затем создает подписку для конкретного типа записи и задает параметр проверяется при триггер. Наконец он определяет тип уведомления, которое будет выполняться при подписке активируется и присоединяет его подписки.

### <a name="saving-subscriptions"></a>Сохранение подписки

С помощью подписки следующий код он сохраняется в базу данных:

```csharp
// Save the subscription to the database
ThisApp.PublicDatabase.SaveSubscription(subscription, (s, err) => {
    // Was there an error?
    if (err != null) {

    }
});
```

С помощью API удобства, вызов асинхронной, простой и обеспечивает обработку ошибок легко.

#### <a name="handling-push-notifications"></a>Обработка Push-уведомлений

Если разработчик использовал ранее Push-уведомлений Apple (APS), процесс работы с уведомления, созданные CloudKit должны быть знакомы.

В `AppDelegate.cs`, переопределить `ReceivedRemoteNotification` следующим образом:

```csharp
public override void ReceivedRemoteNotification (UIApplication application, NSDictionary userInfo)
{
    // Parse the notification into a CloudKit Notification
    var notification = CKNotification.FromRemoteNotificationDictionary (userInfo);

    // Get the body of the message
    var alertBody = notification.AlertBody;

    // Was this a query?
    if (notification.NotificationType == CKNotificationType.Query) {
        // Yes, convert to a query notification and get the record ID
        var query = notification as CKQueryNotification;
        var recordID = query.RecordId;
    }
}
```

Приведенный выше код запрашивает CloudKit для синтаксического анализа сведений о пользователе в CloudKit уведомление. Затем информация извлекается о предупреждении. Наконец проверяется тип уведомления и уведомления будет обрабатывать их соответствующим образом.

В этом разделе показано, как ответить на большие объемы данных, проблема Tiny устройства, представленные выше, с помощью запросов и подписок. Приложение будет оставить его больших объемов данных в облаке и использовать эти технологии для создания представлений в этот набор данных.

## <a name="cloudkit-user-accounts"></a>Учетные записи пользователей CloudKit

Как отмечалось в начале этой статьи, CloudKit построена на основе существующей инфраструктуры iCloud. Ниже рассматривается, подробно, как учетные записи имеют доступ к разработчик, использующий CloudKit API.

### <a name="authentication"></a>Проверка подлинности

При работе с учетными записями пользователей, прежде всего используется проверка подлинности. CloudKit поддерживает проверку подлинности пользователя iCloud вошедшего в систему на устройстве. Проверка подлинности выполняется в фоновом и обрабатывается iOS. Таким образом разработчикам не нужно беспокоиться о подробностях реализации проверки подлинности. Они проверяют только для просмотра, если пользователь вошел в систему.

### <a name="user-account-information"></a>Сведения об учетной записи пользователя

CloudKit обеспечивает следующие сведения о пользователе для разработчиков:

-  **Удостоверение** — способ уникальной идентификации пользователя.
-  **Метаданные** — возможность сохранять и извлекать сведения о пользователях.
-  **Конфиденциальность** — вся информация обрабатывается в манор сознательные конфиденциальности. Ничего не предоставляется, если пользователь согласился его.
-  **Обнаружение** — дает пользователям возможность обнаружения своих друзей, которые используют то же приложение.


Далее мы рассмотрим эти разделы подробно.

#### <a name="identity"></a>идентификации

Как уже говорилось, CloudKit предоставляет способ для приложения для однозначной идентификации конкретного пользователя:

 [![](intro-to-cloudkit-images/image40.png "Однозначно определить данного пользователя")](intro-to-cloudkit-images/image40.png#lightbox)

Есть клиентское приложение, работающее на устройствах пользователя и все базы данных конкретного пользователя Private внутри контейнера CloudKit. Клиентское приложение будет связать с одной из этих конкретных пользователей. Это зависит от пользователя, который выполнил вход в iCloud локально на устройстве.

Поскольку это поступают из iCloud, нет резервного хранилища пользователя форматированного текста. И поскольку iCloud, кем фактически размещена контейнера, его можно сопоставлять пользователей. Приведенная выше, пользователь, учетная запись которого iCloud `user@icloud.com` связана с текущего клиента.

Для каждого контейнера, контейнер идентификатор пользователя уникальный, созданный случайным образом создается и связанный с учетной записью пользователя iCloud (адрес электронной почты). Уникальный идентификатор пользователя возвращается в приложение и может использоваться любым способом разработчик считает нужным.

> [!NOTE]
> Приложениями, запущенными на одном устройстве для одного пользователя iCloud будет иметь разные идентификаторы пользователя, так как они связаны в разные контейнеры CloudKit.

Следующий программный код получает идентификатор пользователя CloudKit для текущего зарегистрированного пользователя iCloud на устройство:

```csharp
public CKRecordID UserID { get; set; }
...

// Get the CloudKit User ID
CKContainer.DefaultContainer.FetchUserRecordId ((recordID, err) => {
    // Was there an error?
    if (err!=null) {
        Console.WriteLine("Error: {0}", err.LocalizedDescription);
    } else {
        // Save user ID
        UserID = recordID;
    }
});
```

Приведенный выше код запрашивает CloudKit контейнере, чтобы идентификатор пользователя, выполнившего вход. Так как эти сведения поступают из iCloud сервера, вызов является асинхронным, и обработка ошибок является обязательным.

#### <a name="metadata"></a>Метаданные

Каждый пользователь в CloudKit имеет определенные метаданные, которые описывают их. Эти метаданные, представлены в виде записи CloudKit:

 [![](intro-to-cloudkit-images/image41.png "Каждый пользователь в CloudKit имеет определенные метаданные, которые описывают их")](intro-to-cloudkit-images/image41.png#lightbox)

Заглянуть внутрь личная база данных для конкретного пользователя существует контейнера по одной записи, который определяет этот пользователь. Существует много записей пользователя внутри базы данных Public, для каждого пользователя контейнера. Один из них будет иметь идентификатор записи, соответствующий текущему идентификатора записи пользователя.

Записи пользователя в общей базе данных, world для чтения. Они обрабатываются, по большей части, как у обычной записи и имеют тип `CKRecordTypeUserRecord`. Эти записи зарезервированы системой и не доступны для запросов.

Используйте указанный ниже код для доступа к записи пользователя:

```csharp
public CKRecord UserRecord { get; set; }
...

// Get the user's record
PublicDatabase.FetchRecord(UserID, (record ,er) => {
    //was there an error?
    if (er != null) {
        Console.WriteLine("Error: {0}", er.LocalizedDescription);
    } else {
        // Save the user record
        UserRecord = record;
    }
});
```

Приведенный выше код отправляет запрос базы данных Public для возврата записи пользователя для пользователя, который является Идентификатором, мы обратились выше. Так как эти сведения поступают из iCloud сервера, вызов является асинхронным, и обработка ошибок является обязательным.

#### <a name="privacy"></a>Конфиденциальность

CloudKit был конструктора по умолчанию для защиты конфиденциальности пользователя, выполнившего вход. По умолчанию предоставляется не персональные идентификационные сведения о пользователе. Существуют случаи, когда приложению будет требоваться ограниченные сведения о пользователе.

В таких случаях приложение может запросить, что пользователь раскрывает эти сведения. Диалоговое окно открывается пользователя запрашиваются согласие на предоставление доступа к своей учетной информацией.

#### <a name="discovery"></a>Обнаружение

При условии, что пользователь как включаются в приложения ограниченный доступ к своей учетной записи пользователя, они могут быть доступными для других пользователей приложения:

 [![](intro-to-cloudkit-images/image42.png "Пользователь может быть доступными для других пользователей приложения")](intro-to-cloudkit-images/image42.png#lightbox)

Клиентское приложение обращается к контейнеру и взаимодействует контейнера iCloud для доступа к данным пользователя. Пользователь может указать адрес электронной почты и обнаружения может использоваться для получения сведений о пользователя. При необходимости идентификатор пользователя также могут использоваться для получения сведений о пользователе.

CloudKit также предоставляет способ для получения сведений о любой пользователь, который может быть дружественными текущего зарегистрированного пользователя iCloud, запросив всей адресной книги. CloudKit процессе извлечения в книге контакта пользователя и использовать адреса электронной почты для просмотра, если его можно найти другие приложения, которое совпадает с этими адресами пользователя.

Это позволяет приложению использовать книги контакта пользователя без предоставления доступа к нему или запросом на утверждение доступ к контактам. Никогда не контактные данные доступны в приложение только CloudKit процесс имеет доступ.

Кратко Напомню, доступны три типа входных данных для обнаружения пользователей:

-  **Идентификатор записи пользователя** — обнаружение эти операции выполняются идентификатор пользователя текущего зарегистрированного в CloudKit пользователя.
-  **Адрес электронной почты пользователя** — пользователь может указать адрес электронной почты, и он может использоваться для обнаружения.
-  **Обратитесь к книге** — адресной книге пользователя может использоваться для обнаружения пользователей приложения, которые имеют один и тот же адрес электронной почты, как указано в свои контакты.


Обнаружение пользователей возвращает следующую информацию:

-  **Идентификатор записи пользователя** -уникальный идентификатор пользователя в базы данных Public.
-  **Первый имя и Фамилия** — как в общей базе данных.


Эта информация будет возвращаться только для пользователей, имеющих обнаружения включен в систему.

Следующий код будет получать информацию о пользователе, вошедшем в iCloud на устройство:

```csharp
public CKDiscoveredUserInfo UserInfo { get; set; }
...

// Get the user's metadata
CKContainer.DefaultContainer.DiscoverUserInfo(UserID, (info, e) => {
    // Was there an error?
    if (e != null) {
        Console.WriteLine("Error: {0}", e.LocalizedDescription);
    } else {
        // Save the user info
        UserInfo = info;
    }
});
```

Используйте указанный ниже код для запроса всех пользователей в книге контакта:

```csharp
// Ask CloudKit for all of the user's friends information
CKContainer.DefaultContainer.DiscoverAllContactUserInfos((info, er) => {
    // Was there an error
    if (er != null) {
        Console.WriteLine("Error: {0}", er.LocalizedDescription);
    } else {
        // Process all returned records
        for(int i = 0; i < info.Count(); ++i) {
            // Grab a user
            var userInfo = info[i];
        }
    }
});
```

В этом разделе мы рассмотрели четыре основные области доступа к учетной записи пользователя, который CloudKit может предоставить приложению. Получение удостоверения пользователя и метаданные, политики конфиденциальности, встроенные в CloudKit и, наконец, возможность обнаружения других пользователей приложения.

## <a name="the-development-and-production-environments"></a>Разработки и рабочей среды

CloudKit предоставляет отдельные среды разработки и эксплуатации типах записей и данные приложения. Среда разработки — более гибкую среду, которая доступна только для членов команды разработчиков. Когда приложение добавляет новое поле к записи и сохраняет эту запись в среде разработки, сервер автоматически обновляет сведения о схеме.

Разработчик может использовать эту функцию для внесения изменений в схему во время разработки, что экономит время. Одно пояснение является то, что после добавления поля к записи, тип данных, связанный с этим полем не может изменяться программно. Чтобы изменить тип поля, разработчик должен удалить поле в [панели мониторинга CloudKit](https://icloud.developer.apple.com/dashboard/) и снова добавьте ее с новым типом.

Перед развертыванием приложения, разработчик можно перенести их схемы и данных в рабочей среде с помощью **панели мониторинга CloudKit**. При выполнении в рабочей среде, сервер не позволяет приложению программно изменение схемы. Разработчик по-прежнему можно внести изменения в **панели мониторинга CloudKit** , но пытается добавить поля в записи в рабочей среде приводят к ошибкам.

> [!NOTE]
> IOS Simulator работает только с **среды разработки**. Когда разработчик готов для тестирования приложения в **рабочей среде**, физическое устройство iOS является обязательным.


## <a name="shipping-a-cloudkit-enabled-app"></a>Приложения с поддержкой доставки CloudKit

Перед отправкой приложения, использующего CloudKit, он должен быть настроен для целевой **рабочей среде CloudKit** или Apple будет отклонять приложения.

Выполните следующие действия:

1. В Visual Studio для Ma компиляции приложения для **выпуска** > **устройства iOS**: 

    [![](intro-to-cloudkit-images/shipping01.png "Компиляция приложения для выпуска")](intro-to-cloudkit-images/shipping01.png#lightbox)

2. Из **построения** меню, выберите **архив**: 

    [![](intro-to-cloudkit-images/shipping02.png "Выберите архив")](intro-to-cloudkit-images/shipping02.png#lightbox)

3. **Архив** будет необходимо создать и отобразить в Visual Studio для Mac: 

    [![](intro-to-cloudkit-images/shipping03.png "Архив будет необходимо создать и отобразить")](intro-to-cloudkit-images/shipping03.png#lightbox)

4. Запустите **Xcode**.
5. Из **окно** меню, выберите **Организатор**: 

    [![](intro-to-cloudkit-images/shipping04.png "Выберите Организатор")](intro-to-cloudkit-images/shipping04.png#lightbox)

6. Выберите архив приложения и нажмите кнопку **экспорт...**  кнопки: 

    [![](intro-to-cloudkit-images/shipping05.png "Архив приложения")](intro-to-cloudkit-images/shipping05.png#lightbox)
    
7. Выберите метод для экспорта и нажмите кнопку **Далее** кнопки: 

    [![](intro-to-cloudkit-images/shipping06.png "Выбор способа экспорта")](intro-to-cloudkit-images/shipping06.png#lightbox)

8. Выберите **команда разработчиков** в раскрывающемся списке и нажмите кнопку **Выбор** кнопки: 

    [![](intro-to-cloudkit-images/shipping07.png "Выберите из раскрывающегося списка группы разработчиков")](intro-to-cloudkit-images/shipping07.png#lightbox)

9. Выберите **рабочей** в раскрывающемся списке и нажмите кнопку **Далее** кнопки: 

    [![](intro-to-cloudkit-images/shipping08.png "Выберите в раскрывающемся списке рабочей среде")](intro-to-cloudkit-images/shipping08.png#lightbox)

10. Проверьте параметр и нажать кнопку **Экспорт** кнопки: 

    [![](intro-to-cloudkit-images/shipping09.png "Проверьте значения параметров")](intro-to-cloudkit-images/shipping09.png#lightbox)

11. Выберите расположение для создания в полученном приложении `.ipa` файл.

Процесс аналогичен и для отправки приложения непосредственно в iTunes Connect, просто нажав кнопку **отправки...**  кнопки, вместо экспорта..., после выбора архива в окне «Организатор».

## <a name="when-to-use-cloudkit"></a>Когда следует использовать CloudKit

Как мы уже видели в этой статье, CloudKit предоставляет простой способ для приложения для хранения и извлечения сведений с серверов iCloud. Неудачна CloudKit не устаревшие или отказаться от любой из существующих средств или платформ.

### <a name="use-cases"></a>Варианты использования

В следующих вариантах применения должно помочь разработчику решение об использовании iCloud определенной платформы или технологии:

-  **Ключ-значение Store iCloud** — асинхронно поддерживает небольшой объем данных в актуальном состоянии и отлично подходит для работы с настройками приложения. Тем не менее он ограничен для очень небольшой объем информации.
-  **iCloud Drive** — созданная на основе существующих iCloud документов API-интерфейсов и предоставляет простой API для синхронизации неструктурированных данных из файловой системы. Он предоставляет полное автономное кэш в Mac OS X и отлично подходит для приложений, предназначенных для документа.
-  **iCloud Core Data** — разрешает передачу данных репликации между всеми устройствах пользователя. Данные находятся в однопользовательском режиме и отлично подходят для хранения частных структурированных данных синхронизации.
-  **CloudKit** — предоставляет общедоступные данные обоих структуру и массового и может обрабатывать большой набор данных и больших неструктурированных файлов. Его равноценных пользователю учетную запись iCloud и предоставляет клиентом передачи данных.


Сохранение эти варианты использования в виду, разработчику необходимо выбрать правильный iCloud технологии обеспечивают текущим функциональным необходимое приложение и хорошую масштабируемость для дальнейшего развития.

## <a name="summary"></a>Сводка

В этой статье подробно рассматривается Краткое введение в CloudKit API. Оно было показано, как подготовить и настроить приложение Xamarin iOS для использования CloudKit. Он описывает возможности API удобства CloudKit. Он имеет show приложения для обеспечения масштабируемости, с помощью запросов и подписки с поддержкой как спроектировать CloudKit. И наконец она показывают данные учетной записи пользователя, предоставляемый приложению CloudKit.

## <a name="related-links"></a>Связанные ссылки

- [CloudKitAtlas (пример)](https://developer.xamarin.com/samples/monotouch/ios8/CloudKitAtlas/)
- [Введение в iOS 8](~/ios/platform/introduction-to-ios8.md)
- [Создание профиля подготовки](~/ios/get-started/installation/device-provisioning/index.md)
