---
title: Работа с потоком пользовательского интерфейса в Xamarin.iOS
description: В этом документе описывается, как работать с потока пользовательского интерфейса в Xamarin.iOS. Описывает выполнение потока пользовательского интерфейса, пример фонового потока и проверяет async/await.
ms.prod: xamarin
ms.assetid: 98762ACA-AD5A-4E1E-A536-7AF3BE36D77E
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/21/2017
ms.openlocfilehash: 6dd55f5c4316ed8f1d4f16d9e282cc2647350518
ms.sourcegitcommit: e268fd44422d0bbc7c944a678e2cc633a0493122
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "50104860"
---
# <a name="working-with-the-ui-thread-in-xamarinios"></a>Работа с потоком пользовательского интерфейса в Xamarin.iOS

Пользовательских интерфейсов приложений всегда являются однопоточными, даже в многопоточных устройств — имеется только одно представление для экрана и любые изменения отображаемых необходимо согласовать через один «точки доступа». Благодаря этому несколько потоков пытаются обновить же пикселу в то же время (например).

Код следует добавлять только поток изменений в элементы управления интерфейса из главного пользователя (или пользовательского интерфейса). Обновления интерфейса пользователя, которые происходят в другом потоке (например, обратный вызов или фоновый поток) не может получить отображен на экране, или даже может привести к сбою.

## <a name="ui-thread-execution"></a>Выполнение потока пользовательского интерфейса

При создании элементов управления в представлении, или обработка инициированного пользователем события, такие как сенсорного ввода, код выполняется в контексте потока пользовательского интерфейса.

Если код выполняется в фоновом потоке, в задачу или обратный вызов будет скорее всего, не выполняется в основном потоке пользовательского интерфейса. В этом случае необходимо заключить код при вызове `InvokeOnMainThread` или `BeginInvokeOnMainThread` следующим образом:

```csharp
InvokeOnMainThread ( () => {
    // manipulate UI controls
});
```

`InvokeOnMainThread` Метод определяется для `NSObject` , его можно вызвать из методов, определенных для любого объекта UIKit (например, представления или контроллера представления).

Во время отладки приложений Xamarin.iOS, ошибка возникает, если код пытается получить доступ к элемент управления пользовательского интерфейса из неправильного потока. Это поможет вам отследить и устранить проблемы с помощью метода InvokeOnMainThread. Это только происходит во время отладки и вызывает ошибку в сборках выпуска. Сообщение об ошибке будет выглядеть следующим образом:

 ![](ui-thread-images/image10.png "Выполнение потока пользовательского интерфейса")

 <a name="Background_Thread_Example" />


## <a name="background-thread-example"></a>Пример фонового потока

Ниже приведен пример, который пытается получить доступ к элементу управления пользовательского интерфейса ( `UILabel`) из фонового потока с использованием простого потока:

```csharp
new System.Threading.Thread(new System.Threading.ThreadStart(() => {
    label1.Text = "updated in thread"; // should NOT reference UILabel on background thread!
})).Start();
```

Что будет генерировать код `UIKitThreadAccessException` во время отладки. Чтобы устранить проблему (и убедитесь, что интерфейс пользовательского элемента управления осуществляется только из основного потока пользовательского интерфейса), заключите любой код, который ссылается на элементы управления пользовательского интерфейса внутри `InvokeOnMainThread` выражение следующим образом:

```csharp
new System.Threading.Thread(new System.Threading.ThreadStart(() => {
    InvokeOnMainThread (() => {
        label1.Text = "updated in thread"; // this works!
    });
})).Start();
```

Вы должны не используется далее в примерах в этом документе, но это важная концепция запоминать, когда приложение выполнит сетевые запросы, использует Центр уведомлений или других методов, которые требуют завершения обработчик, который будет выполняться на другом поток.

 <a name="Async_Await_Example" />


## <a name="asyncawait-example"></a>Пример ASYNC/Await

При использовании C# 5 ключевых слов async/await `InvokeOnMainThread` является не обязательным, поскольку при завершении ожидаемая задача метод продолжает в вызывающем потоке.

Этот пример кода (который ожидает завершения при вызове метода задержки, исключительно для демонстрационных целей) показан асинхронный метод, который вызывается в потоке пользовательского интерфейса (это обработчик TouchUpInside). Поскольку содержащего метода вызывается в потоке пользовательского интерфейса, операций пользовательского интерфейса, такие как задания текста на `UILabel` или отображение `UIAlertView` может быть вызван после завершения асинхронных операций в фоновых потоках.

```csharp
async partial void button2_TouchUpInside (UIButton sender)
{
    textfield1.ResignFirstResponder ();
    textfield2.ResignFirstResponder ();
    textview1.ResignFirstResponder ();
    label1.Text = "async method started";
    await Task.Delay(1000); // example purpose only
    label1.Text = "1 second passed";
    await Task.Delay(2000);
    label1.Text = "2 more seconds passed";
    await Task.Delay(1000);
    new UIAlertView("Async method complete", "This method", 
               null, "Cancel", null)
        .Show();
    label1.Text = "async method completed";
}
```

Если асинхронный метод вызывается из фонового потока (не основной поток ИП) затем `InvokeOnMainThread` по-прежнему не требуются.


## <a name="related-links"></a>Связанные ссылки

- [Элементы управления (пример)](https://developer.xamarin.com/samples/Controls/)
- [Работа с потоками](~/ios/app-fundamentals/threading.md)
