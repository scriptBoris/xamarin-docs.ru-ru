---
title: Общие сведения о MonoTouch.Dialog для Xamarin.iOS
description: В этом документе описывается MonoTouch.Dialog (машинного перевода. (Г), это платформа для быстрой, декларативной разработки пользовательского интерфейса с помощью Xamarin.iOS. В этом примере рассматривается использование API-интерфейсы MonoTouch.Dialog создавать интерфейс в коде или JSON и использовать такие функции, как по запросу для обновления, поиска, фоновая загрузка образа и многое другое.
ms.prod: xamarin
ms.assetid: 52A35B24-C23B-8461-A8FF-5928A2128FB0
ms.technology: xamarin-ios
ms.date: 11/25/2015
author: lobrien
ms.author: laobri
ms.openlocfilehash: c291a440a1937d2b0f1c229e3fa969caedba9ab9
ms.sourcegitcommit: 729035af392dc60edb9d99d3dc13d1ef69d5e46c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50675462"
---
# <a name="introduction-to-monotouchdialog-for-xamarinios"></a>Общие сведения о MonoTouch.Dialog для Xamarin.iOS

Контроллер представления MonoTouch.Dialog, называются MT. D для краткости, является быстрое пакет средств разработки пользовательского интерфейса, который позволяет разработчикам создавать экраны приложения и навигации, используя сведения, а не долгой Создание контроллеров представлений, таблиц и т.д. Таким образом он предоставляет значительное упрощение уменьшения разработки и код пользовательского интерфейса. Например рассмотрим следующий снимок экрана:

 [![](images/image1.png "Например рассмотрим этот снимок экрана")](images/image1.png#lightbox)

Следующий код был использован для определения этого весь экран:

```csharp
public enum Category
{
    Travel,
    Lodging,
    Books
}
        
public class Expense
{
    [Section("Expense Entry")]

    [Entry("Enter expense name")]
    public string Name;
    [Section("Expense Details")]
  
    [Caption("Description")]
    [Entry]
    public string Details;
        
    [Checkbox]
    public bool IsApproved = true;
    [Caption("Category")]
    public Category ExpenseCategory;
}
```

При работе с таблицами в iOS, обычно имеется тонна повторы кода.
Например каждый раз при необходимости таблицы источника данных требуется для заполнения этой таблицы. Каждый экран в приложение с двумя экранами на основе таблицы, которые подключены через контроллер навигации, делится своими массу тот же код.

ГЛАВНОГО ЦЕЛЕВОГО СЕРВЕРА D упрощает, инкапсуляция весь этот код в универсальном API для создания таблицы. Затем она предоставляет это абстракция на основе этого API, позволяющий выполнять объект декларативный синтаксис, обеспечивающие удобство привязки. Таким образом существует два API доступны в главного целевого сервера D:

-   **Низкоуровневые API элементов** — *элементы API* основана на создании иерархическое дерево элементов, которые представляют экраны и их компонентов. API элементов предоставляет разработчикам наиболее гибкость и управляемость при создании пользовательских интерфейсов. Кроме того API элементов расширенную поддержку декларативного определения через JSON, что позволяет как объявление очень быстро, так и динамическое создание пользовательского интерфейса с сервера. 
-   **Высокоуровневый API отражения** — также называется *привязки**API* , в каких классах помечены атрибутом подсказки пользовательского интерфейса, а затем главного целевого сервера D автоматически создает экраны, на основе объектов и предоставляет привязку между что отображается (и при необходимости редактируется) на экране, и у базового объекта резервного.   Приведенном выше примере показано использование API-интерфейса отражения. Этот API не обеспечивает детального контроля, который выполняет элементы API, но он снижает сложность еще дальше, автоматически создав out иерархии элементов, исходя из атрибутов класса. 


ГЛАВНОГО ЦЕЛЕВОГО СЕРВЕРА D поставляется упакованным с большим набором встроенных элементов пользовательского интерфейса для создания экрана, но он также осознают необходимость специализированными элементами и макеты расширенный экран. Таким образом расширяемость является первого класса популярных функционала, реализованного в API. Разработчики могут расширять существующие элементы или создавать новые и легко интегрируются.

Кроме того главного целевого сервера D имеет ряд общих функций интерфейса пользователя iOS, встроенные, такие как «по запросу обновления» поддерживает асинхронной загрузки, изображения и поиск поддержки.

В этой статье займет исчерпывающие работа с главного целевого сервера D, включая:

-   **ГЛАВНОГО ЦЕЛЕВОГО СЕРВЕРА Компоненты D** — это основное внимание уделяется Общие сведения о классах, составляющих главного целевого сервера D, чтобы быстро получить в курс дела. 
-   **Справочник по элементам** — полный список встроенных элементов машинного перевода. Г. 
-   **Расширенное использование** — здесь речь идет о расширенных функций, таких как по запросу для обновления, поиска, фоновую загрузку образа, с помощью LINQ для создания иерархии элементов и создание пользовательских элементов, ячейки, и контроллеры для использования с главного целевого сервера Г. 

## <a name="setting-up-mtd"></a>Настройка главного целевого сервера D

ГЛАВНОГО ЦЕЛЕВОГО СЕРВЕРА D распространяется вместе с Xamarin.iOS. Чтобы использовать его, щелкните правой кнопкой мыши **ссылки** Xamarin.iOS узел проекта в Visual Studio 2017 или Visual Studio для Mac и добавьте ссылку на **MonoTouch.Dialog 1** сборки. Затем добавьте `using MonoTouch.Dialog` инструкций в источнике кода при необходимости.

## <a name="understanding-the-pieces-of-mtd"></a>Основные сведения о части главного целевого сервера D

Даже в том случае, если с помощью отражения API, главного целевого сервера D создает иерархию элемент скрытым, как если бы он был создан непосредственно с помощью API элементов. Кроме того Поддержка JSON, упомянутые в предыдущем разделе создает элементы также. По этой причине важно иметь базовое представление о составляющих элементов машинного перевода. Г.

ГЛАВНОГО ЦЕЛЕВОГО СЕРВЕРА D сборок экраны с помощью следующих четырех частей:

-  **DialogViewController**
-  **RootElement**
-  **Раздел**
-  **Элемент**


### <a name="dialogviewcontroller"></a>DialogViewController

Объект *DialogViewController*, или *DVC* для краткости, наследует от `UITableViewController` и поэтому представляет экран с таблицей. DVCs может быть принудительно передана в контроллер навигации так же, как обычный UITableViewController.

### <a name="rootelement"></a>RootElement

Объект *RootElement* является контейнером верхнего уровня для элементов, входящих в DVC. Он содержит разделы, в которых может содержать элементы. Элементы RootElement не подготавливаются к просмотру; Вместо этого они просто контейнеры для что получает отрисовка. RootElement назначается DVC, и затем DVC отображает его дочерних элементов.

### <a name="section"></a>Раздел

Раздел — это группа ячеек в таблице. Как и обычная таблица разделом, при необходимости верхний и нижний колонтитулы, могут быть текстом или даже пользовательские представления, как показано на снимке:

 [![](images/image2.png "Как и обычная таблица разделом, при необходимости верхний и нижний колонтитулы, могут быть текстом или даже пользовательские представления, как показано на этом снимке экрана")](images/image2.png#lightbox)

### <a name="element"></a>Элемент

Элемент представляет фактический ячейку в таблице. ГЛАВНОГО ЦЕЛЕВОГО СЕРВЕРА D следует упакованным с большим количеством элементов, которые представляют различные типы данных или различные входные данные. Например далее на снимках экрана показаны некоторые из доступных элементов:

 [![](images/image3.png "Например это снимках экрана показано несколько доступных элементов")](images/image3.png#lightbox)

## <a name="more-on-sections-and-rootelements"></a>В разделах и элементы RootElement

Давайте теперь рассмотрим элементы RootElement и разделах более подробно.

### <a name="rootelements"></a>Элементы RootElement

Чтобы начать процесс MonoTouch.Dialog требуется по крайней мере один RootElement.

Если RootElement инициализируется со значением элемент/section это значение используется для поиска дочерний элемент, который предоставит сводку конфигурации, которая отображается в правой части экрана. Например на следующем снимке экрана показана таблица в левой части с ячейку, содержащую заголовок на экране сведений в правой части, «Dessert», вместе со значением выбранного Гоби.

 [![](images/image4.png "На этом снимке экрана показана таблица, в левой части с ячейку, содержащую заголовок на экране сведений в правой части, Dessert, вместе со значением выбранного Гоби")](images/image4.png#lightbox) [![](images/image5.png "это Снимок экрана ниже показана таблица в левой части с ячейку, содержащую заголовок на экране сведений в правой части, Dessert, вместе со значением выбранного Гоби")](images/image5.png#lightbox)

Корневые элементы также можно в разделах для запуска при загрузке новой страницы вложенной конфигурации, как показано выше. В этом режиме указан заголовок, используемых при подготовке к просмотру в раздел и также используется в качестве заголовка для подстраниц. Пример:

```csharp
var root = new RootElement ("Meals") {
    new Section ("Dinner"){
            new RootElement ("Dessert", new RadioGroup ("dessert", 2)) {
                new Section () {
                    new RadioElement ("Ice Cream", "dessert"),
                    new RadioElement ("Milkshake", "dessert"),
                    new RadioElement ("Chocolate Cake", "dessert")
                }
            }
        }
    }
```

В приведенном выше примере когда пользователь нажимает на «Dessert», контроллер представления MonoTouch.Dialog будет создать новую страницу и перейдите к нему с корневым элементом будет «Dessert» и создать группу переключателей с тремя значениями.

В этом образце группы переключателей выберет «Шоколадное Пирожное» в разделе «Dessert», так как мы передали значение «2» RadioGroup. Это означает подбор 3-й элемент в списке (нулевой индекс).

Вызов метода Add или с помощью синтаксиса инициализатора C# 4 добавляет разделы.
Методы вставки, позволяющих вставить разделы с анимацией.

При создании экземпляра группы (вместо RadioGroup) RootElement суммарного значения RootElement при отображении в раздел будет совокупного количества всех BooleanElements и CheckboxElements, имеют один и тот же ключ как значение Group.Key.

### <a name="sections"></a>Разделы

Разделы используются для группы элементов на экране и являются единственным допустимым прямой дочерний элемент элемента RootElement. Разделы могут содержать любой из стандартных элементов, включая новые элементы RootElement.

Элементы RootElement, внедренных в разделе используются для перехода на новый уровень глубже.

Состав разделов могут входить верхние и нижние колонтитулы в виде строк или UIViews.
Как правило, используются только строки, но для создания пользовательских интерфейсах можно использовать любой UIView как верхний или нижний колонтитул. Строка либо можно использовать для создания их следующим образом:

```csharp
var section = new Section ("Header", "Footer")
```

Использовать представления, просто передайте конструктору представлений:

```csharp
var header = new UIImageView (Image.FromFile ("sample.png"));
var section = new Section (header)
```

### <a name="getting-notified"></a>Получение уведомления

#### <a name="handling-nsaction"></a>Обработка NSAction

ГЛАВНОГО ЦЕЛЕВОГО СЕРВЕРА D поверхности `NSAction` качестве делегата для обработки обратных вызовов.
Например предположим, что вам нужно обрабатывать событие сенсорного ввода для ячейки таблицы, созданные с главного целевого сервера Г. При создании элемента с помощью машинного перевода. D, просто введите функцию обратного вызова, как показано ниже:

```csharp
new Section () {
        new StringElement ("Demo Callback", 
                delegate { Console.WriteLine ("Handled"); })
}
```

#### <a name="retrieving-element-value"></a>Извлечение значения элемента

В сочетании с `Element.Value` свойств, обратный вызов можно получить значение, заданное в других элементах. Рассмотрим следующий пример кода:

```csharp
var element = new EntryElement (task.Name, "Enter task description",
        task.Description);
                
var taskElement = new RootElement (task.Name){
        new Section () { element },
        new Section () { 
                new DateElement ("Due Date", task.DueDate)
        },
        new Section ("Demo Retrieving Element Value") {
                new StringElement ("Output Task Description", 
                        delegate { Console.WriteLine (element.Value); })
        }
};
```

Этот код создает пользовательский Интерфейс, как показано ниже. Полное Пошаговое руководство по в этом примере, см. в разделе [Пошаговое руководство по API элементы](~/ios/user-interface/monotouch.dialog/elements-api-walkthrough.md) руководства.

 [![](images/image6.png "В сочетании со свойством Element.Value, обратный вызов можно получить значение, заданное в других элементах")](images/image6.png#lightbox)

Когда пользователь нажимает нижнюю ячейку таблицы, выполняет код в анонимной функции, записи значения из `element` экземпляр **выходные данные приложения** панели в Visual Studio для Mac.

## <a name="built-in-elements"></a>Встроенные элементы

ГЛАВНОГО ЦЕЛЕВОГО СЕРВЕРА D поставляется с количеством элементов ячейки встроенных таблиц, известные как элементы.
Эти элементы используются для отображения в ячейках таблицы, такие как строки, числа с плавающей запятой, дат и даже изображения для прочих разнообразных типов. Каждый элемент отвечает за отображение типа данных соответствующим образом. К примеру логический элемент будет отображаться параметр для переключения его значение. Аналогичным образом это число с плавающей запятой элемент будет отображаться ползунок, чтобы изменить значение с плавающей запятой.

Существует еще более сложных элементов для поддержки расширенные типы данных, таких как изображения и html. Например HTML-элемент, который будет открываться UIWebView для загрузки веб-страницы при выборе, отображается заголовок в ячейке таблицы.

### <a name="working-with-element-values"></a>Работа с значения элементов

Элементы, которые используются для записи введенных данных предоставлять открытый `Value` свойство, которое содержит текущее значение элемента в любое время. Она автоматически обновляется, так как пользователь использует приложение.

Это поведение для всех элементов, которые являются частью MonoTouch.Dialog, но он не является обязательным для элементов, созданных пользователем.

### <a name="string-element"></a>Элемент строку

Объект `StringElement` показывает заголовок в левой части ячейки таблицы и строковое значение правой стороны ячейки.

 [![](images/image7.png "StringElement показывает заголовок в левой части ячейки таблицы и строковое значение правой стороны ячейки")](images/image7.png#lightbox)

Чтобы использовать `StringElement` как кнопка, предоставьте делегат.

```csharp
new StringElement (
        "Click me",
        () => { new UIAlertView("Tapped", "String Element Tapped"
, null, "ok", null).Show(); })
```

 [![](images/image8.png "Чтобы использовать StringElement как кнопка, предоставьте делегат")](images/image8.png#lightbox)

### <a name="styled-string-element"></a>Элемент строку с примененным стилем

Объект `StyledStringElement` позволяет представлять с помощью либо Встроенная таблица стилей ячейки строки или с помощью пользовательского форматирования.

 [![](images/image9.png "StyledStringElement позволяет представлять с помощью либо Встроенная таблица стилей ячейки строки или с помощью пользовательского форматирования")](images/image9.png#lightbox)

`StyledStringElement` Класс является производным от `StringElement`, но позволяет разработчикам настраивать небольшое число свойств, таких как шрифт, цвет текста, цвет фона ячейки, режим переноса строки, количество строк для отображения, и отображением периферийного устройства.

### <a name="multiline-element"></a>Многострочный элемент

 [![](images/image10.png "Многострочный элемент")](images/image10.png#lightbox)

### <a name="entry-element"></a>Элемент

`EntryElement`, Как имя подразумевает, используемый для получения входных данных пользователя. Он поддерживает обычные строки или пароли, где символы скрыты.

 [![](images/image11.png "EntryElement используется для получения входных данных пользователя")](images/image11.png#lightbox)

Он инициализируется с тремя значениями:

-  Заголовок для записи, которая будет отображаться для пользователя.
-  Текст заполнителя (это серым текст, который предоставляет подсказку для пользователя). 
-  Значение текста.


Заполнитель и значение может иметь значение null. Однако заголовок является обязательным.

В любой момент при обращении к свойству его значение можно получить значение `EntryElement`.

Кроме того `KeyboardType` свойство можно задать во время создания стиля тип клавиатуры, требуемого для ввода данных. Это может использоваться для настройки клавиатуры с использованием значения `UIKeyboardType` перечисленные ниже:

-  Numeric
-  Номер телефона
-  URL-адрес
-  Адрес эл. почты


### <a name="boolean-element"></a>Логический элемент

 [![](images/image12.png "Логический элемент")](images/image12.png#lightbox)

### <a name="checkbox-element"></a>Элемент флажка

 [![](images/image13.png "Элемент флажка")](images/image13.png#lightbox)

### <a name="radio-element"></a>Элемент переключатель

Объект `RadioElement` требует `RadioGroup` в `RootElement`.

```csharp
mtRoot = new RootElement ("Demos", new RadioGroup("MyGroup", 0))
```

 [![](images/image14.png "RadioElement требует RadioGroup в RootElement")](images/image14.png#lightbox)

 `RootElements` также используются для координации radio элементов. `RadioElement` Члены могут охватывать несколько разделов (например для реализации примерно селектор кольцо тон и отдельные пользовательские мелодии из системы мелодии звонка). Представление "Сводка" отображается элемент переключатель, выбранное в настоящий момент. Чтобы использовать это, создайте `RootElement` с помощью конструктора, группы, следующим образом:

```csharp
var root = new RootElement ("Meals", new RadioGroup ("myGroup", 0))
```

Имя группы в `RadioGroup` используется для отображения значения, выбранного в страницу (если таковые имеются) и значение, которое в данном случае равен нулю, — это индекс первого выбранного элемента.

### <a name="badge-element"></a>Значок элемента

 [![](images/image15.png "Значок элемента")](images/image15.png#lightbox)

### <a name="float-element"></a>Float-элемент

 [![](images/image16.png "Float-элемент")](images/image16.png#lightbox)

### <a name="activity-element"></a>Элемент действия

 [![](images/image17.png "Элемент действия")](images/image17.png#lightbox)

### <a name="date-element"></a>Элемент Дата

 ![](images/image18.png "Элемент Дата")

При выборе ячейку, соответствующую DateElement управляющий элемент выбора даты представляется, как показано ниже:

 [![](images/image19.png "При выборе ячейку, соответствующую DateElement управляющий элемент выбора даты представлен, как показано")](images/image19.png#lightbox)

### <a name="time-element"></a>Элемент Time

 [![](images/image20.png "Элемент Time")](images/image20.png#lightbox)

При выборе ячейку, соответствующую TimeElement средство выбора времени представляется, как показано ниже:

 [![](images/image21.png "При выборе ячейку, соответствующую TimeElement средство выбора времени представляется, как показано")](images/image21.png#lightbox)

### <a name="datetime-element"></a>Элемент даты и времени

 [![](images/image22.png "Элемент даты и времени")](images/image22.png#lightbox)

При выборе ячейку, соответствующую DateTimeElement элемент выбора даты и времени представляется, как показано ниже:

 [![](images/image23.png "При выборе ячейку, соответствующую DateTimeElement элемент выбора даты и времени будет выглядеть, как показано")](images/image23.png#lightbox)

### <a name="html-element"></a>HTML-элемент

 [![](images/image24.png "HTML-элемент")](images/image24.png#lightbox)

`HTMLElement` Отображает значение его `Caption` свойство ячейки таблицы. Флажок установлен, где `Url` элементу загружается в `UIWebView` управления, как показано ниже:

 [![](images/image25.png "URL-адрес, назначенный элементу загружается в элемент управления UIWebView, как показано ниже, где выбран")](images/image25.png#lightbox)

### <a name="message-element"></a>Элемент Message

 [![](images/image26.png "Элемент Message")](images/image26.png#lightbox)

### <a name="load-more-element"></a>Загрузить дополнительные элемент

Этот элемент используется, чтобы разрешить пользователям загрузку дополнительных элементов в списке. Вы можете настроить нормали и загрузка субтитры, а также шрифт и цвет текста.
`UIActivity` Индикатор начинается анимация, и подпись загрузки отображается в том случае, когда пользователь касается ячейки, а затем `NSAction` передан в конструктор выполняется. Один раз в коде `NSAction` завершения работы, `UIActivity` индикатор останавливает анимации и обычный заголовок отображается снова.

### <a name="uiview-element"></a>Элемент UIView

Кроме того, любые пользовательские `UIView` могут отображаться с помощью `UIViewElement`.

### <a name="owner-drawn-element"></a>Рисуемый владельцем элемент

Этот элемент должен быть подклассом как он является абстрактным классом. Необходимо переопределить `Height(RectangleF bounds)` метод, в котором следует возвращать высоту элемента, а также `Draw(RectangleF bounds, CGContext context, UIView view)` в которой делать все настроенные рисование в пределах заданного с помощью параметров контекста и представления. Этот элемент осуществляет трудную работу из подклассов `UIView`и поместить его в ячейке следует возвратить пользователя останется только при необходимости реализовывать два простых переопределений. Вы увидите для оптимальной реализации образца в примере приложения в `DemoOwnerDrawnElement.cs` файл.

Ниже приведен очень простой пример реализации класса:

```csharp
public class SampleOwnerDrawnElement : OwnerDrawnElement
 {
    public SampleOwnerDrawnElement (string text) : base(UITableViewCellStyle.Default, "sampleOwnerDrawnElement")
    {
        this.Text = text;
    }

    public string Text
    {
        get;set;    
    }

    public override void Draw (RectangleF bounds, CGContext context, UIView view)
    {
        UIColor.White.SetFill();
        context.FillRect(bounds);

        UIColor.Black.SetColor();   
        view.DrawString(this.Text, new RectangleF(10, 15, bounds.Width - 20, bounds.Height - 30), UIFont.BoldSystemFontOfSize(14.0f), UILineBreakMode.TailTruncation);
    }

    public override float Height (RectangleF bounds)
    {
        return 44.0f;
    }
 }
```

### <a name="json-element"></a>Элемент JSON

`JsonElement` Является подклассом `RootElement` , расширяющий `RootElement` сможет загрузить содержимое вложенные дочерние из локального или удаленного URL-адреса.

`JsonElement` — `RootElement` Могут создаваться в двух формах. Создает одну версию `RootElement` , будет загружать содержимое по запросу. Они создаются с помощью `JsonElement` конструкторы, принимающие дополнительный аргумент в конце URL-адрес для загрузки содержимого из:

```csharp
var je = new JsonElement ("Dynamic Data", "http://tirania.org/tmp/demo.json");
```

Другая форма создает данные из локального файла или существующий `System.Json.JsonObject` , уже анализа:

```csharp
var je = JsonElement.FromFile ("json.sample");
using (var reader = File.OpenRead ("json.sample"))
    return JsonElement.FromJson (JsonObject.Load (reader) as JsonObject, arg);
```

Дополнительные сведения об использовании JSON с главного целевого сервера D, см. в разделе [пошаговом руководстве элемент JSON](http://docs.xamarin.com/guides/ios/user_interface/monotouch.dialog/json_element_walkthrough) руководства.

## <a name="other-features"></a>Другие возможности

### <a name="pull-to-refresh-support"></a>Поддержка по запросу для обновления

 *По запросу-к-* *обновить* визуальный эффект изначально находится в *Tweetie2* приложения, который стал популярных эффект для многих приложений.

Чтобы добавить свои диалоги автоматическая поддержка по запросу для обновления, необходимо только сделать две вещи: подключить обработчик событий, чтобы получать уведомления, когда пользователь запрашивает данные и уведомить `DialogViewController` при загрузки данных, чтобы вернуться к состоянию по умолчанию.

Подключая уведомление прост; просто подключите к `RefreshRequested` событий на `DialogViewController`, следующим образом:

```csharp
dvc.RefreshRequested += OnUserRequestedRefresh;
```

Затем в методе `OnUserRequestedRefresh`, вам бы некоторые загрузка данных в очередь, некоторые данные запроса от net или запустить поток для вычисления данных. После загрузки данных, необходимо уведомить `DialogViewController` новые данные, и чтобы восстановить представление к состоянию по умолчанию, это делается путем вызова `ReloadComplete`:

```csharp
dvc.ReloadComplete ();
```

### <a name="search-support"></a>Поддержка поиска

Для поддержки поиска, задайте `EnableSearch` свойство вашей `DialogViewController`. Можно также задать `SearchPlaceholder` свойство для использования в качестве текста водяного знака в строке поиска.

Поиск приведет к изменению содержимого представления когда пользователь вводит текст. Он выполняет видимых полей и показывает и те, для пользователя. `DialogViewController` Предоставляет три метода, чтобы программно инициировать, окончание или активировать новую операцию фильтра на результаты. Эти методы перечислены ниже.

-  `StartSearch`
-  `FinishSearch`
-  `PerformFilter`


Система является расширяемой, поэтому это поведение можно изменить, если требуется.

### <a name="background-image-loading"></a>Фоновая загрузка образа

Включает контроллер представления MonoTouch.Dialog [TweetStation](https://github.com/migueldeicaza/TweetStation) загрузчик образов приложения. Этот загрузчик изображений можно использовать для загрузки изображений в фоновом режиме, поддерживает кэширование и можно учитывалась в коде, после загрузки изображения.

Оно также будет ограничивает количество исходящих сетевых подключений.

Загрузчик образов реализуется в `ImageLoader` класс, все что нужно сделать — вызов `DefaultRequestImage` метод, необходимо будет указать Uri для образа, который нужно загрузить, а также экземпляр `IImageUpdated` интерфейс, который будет вызывается при изображение высокого уровня доступности s, загружена.

Например следующий код загружает изображение из URL-адрес в `BadgeElement`:

```csharp
string uriString = "http://some-server.com/some image url";

var rootElement = new RootElement("Image Loader") {
        new Section(){
                new BadgeElement( ImageLoader.DefaultRequestImage( new Uri(uriString), this), "Xamarin")
        }
};
```

ImageLoader-класс предоставляет метод очистки, которые можно вызывать, если необходимо освободить все образы, которые в настоящее время хранятся в памяти. Текущий код не имеет кэша для 50 образов. Если вы хотите использовать размер кэша (например, если ожидаются изображения слишком большой, что 50 изображения должно быть слишком много), можно просто создать экземпляры ImageLoader и передать число образов, которые будут храниться в кэше.

## <a name="using-linq-to-create-element-hierarchy"></a>Использование LINQ для создания иерархии элементов

С помощью clever использованию LINQ и C# синтаксис инициализации LINQ можно использовать для создания иерархии элемента. Например, следующий код создает экрана из некоторых массивы строк и дескрипторов ячейки выбора с помощью анонимную функцию, которая передается в каждую `StringElement`:

```csharp
var rootElement = new RootElement ("LINQ root element") {
from x in new string [] { "one", "two", "three" }
select new Section (x) {
from y in "Hello:World".Split (':')
select (Element) new StringElement (y,
delegate { Debug.WriteLine("cell tapped"); })
}
};
```

Этот параметр может легко использовать совместно с хранилище XML-данных или данных из базы данных для создания сложных приложений почти полностью на основе данных.

## <a name="extending-mtd"></a>Расширение главного целевого сервера D

### <a name="creating-custom-elements"></a>Создание настраиваемых элементов

Можно создать собственный элемент, путем наследования из любого существующего элемента или путем наследования от класса корневого элемента.

Для создания собственного элемента, необходимо переопределить следующие методы:

```csharp
// To release any heavy resources that you might have
    void Dispose (bool disposing);

    // To retrieve the UITableViewCell for your element
    // you would need to prepare the cell to be reused, in the
    // same way that UITableView expects reusable cells to work
    UITableViewCell GetCell (UITableView tv)

    // To retrieve a "summary" that can be used with
    // a root element to render a summary one level up.  
    string Summary ()
    // To detect when the user has tapped on the cell
    void Selected (DialogViewController dvc, UITableView tableView, NSIndexPath path)
    // If you support search, to probe if the cell matches the user input
    bool Matches (string text)
```

Если ваш элемент может иметь переменный размер, необходимо реализовать `IElementSizing` интерфейс, который содержит один метод:

```csharp
// Returns the height for the cell at indexPath.Section, indexPath.Row
    float GetHeight (UITableView tableView, NSIndexPath indexPath);
```

Если вы планируете для реализации вашей `GetCell` , вызывая `base.GetCell(tv)` и настройка возвращенную ячейку, необходимо также переопределить `CellKey` ключом, который будет уникальной для элемента, возвращаемого свойства следующим образом:

```csharp
static NSString MyKey = new NSString ("MyKey");
    protected override NSString CellKey {
        get {
            return MyKey;
        }
    }
```

Это работает для большинства элементов, но не для `StringElement` и `StyledStringElement` как их использовать свои собственные набор ключей для различных сценариев подготовки к просмотру. Пришлось бы реплицировать код в этих классах.

### <a name="dialogviewcontrollers-dvcs"></a>DialogViewControllers (DVCs)

Отражение и элементы API используйте тот же `DialogViewController`. Иногда требуется настроить внешний вид представления или может потребоваться использовать некоторые возможности `UITableViewController` выходят за рамки базовое Создание интерфейсов пользователя.

`DialogViewController` Является просто подклассом `UITableViewController` и его можно настроить таким же образом, при настройке `UITableViewController`.

Например, если вы хотите изменить стиль списка должен быть `Grouped` или `Plain`, можно задать это значение путем изменения свойства при создании контроллера, следующим образом:

```csharp
var myController = new DialogViewController (root, true){
        Style = UITableViewStyle.Grouped;
    }
```

Для создания расширенных настроек из `DialogViewController`, такие как установка фоном, как подкласс его и переопределения соответствующих методов, как показано в следующем примере:

```csharp
class SpiffyDialogViewController : DialogViewController {
    UIImage image;

    public SpiffyDialogViewController (RootElement root, bool pushing, UIImage image) 
        : base (root, pushing) 
    {
        this.image = image;
    }

    public override LoadView ()
    {
        base.LoadView ();
        var color = UIColor.FromPatternImage(image);
        TableView.BackgroundColor = UIColor.Clear;
        ParentViewController.View.BackgroundColor = color;
    }
}
```

Другая точка настройки является следующие виртуальные методы в `DialogViewController`:

```csharp
public override Source CreateSizingSource (bool unevenRows)
```

Этот метод должен возвращать подкласс `DialogViewController.Source` для случаев, где ячейкам равномерным или подкласс `DialogViewController.SizingSource` Если неравные ячейкам.

Это переопределение позволяет выделить `UITableViewSource` методы. Например [TweetStation](https://github.com/migueldeicaza/TweetStation) использует его для отслеживания, когда пользователь прокручивает вверх и соответствующим образом обновить количество непрочитанных твитов.

## <a name="validation"></a>Проверка

Элементы не обеспечивают проверку себя как модели, которые хорошо подходят для веб-страниц и классических приложений не сопоставляются непосредственно модель взаимодействия iPhone.

Если вы хотите выполнить проверку данных, делать это когда пользователь запускает действие с данными, введенными. Например <span class="ui">сделать</span> или <span class="ui">Далее</span> кнопки в верхней части панели инструментов и некоторые `StringElement` используется в качестве кнопки, чтобы перейти к следующему этапу.

Это, когда необходимо выполнить основные проверки входных данных, и может быть более сложным проверки, такие как проверка для действия сочетания имени пользователя и пароля с сервером.

Как уведомлять пользователя об ошибке, зависит от приложения. Удалось всплывающее окно `UIAlertView` или показывать подсказку.

## <a name="summary"></a>Сводка

В этой статье рассматриваются массу информации о MonoTouch.Dialog. Это обсуждалось принципы машинного перевода. D работает и рассматриваются различные компоненты, составляющие главного целевого сервера Г. Он также показал множество различных элементов и таблицы настроек, поддерживаемых главного целевого сервера D и рассматривается как главного целевого сервера D можно расширить с помощью настраиваемых элементов. Кроме того, оно описывает поддержке JSON в главного целевого сервера D, которая позволяет динамически создавать элементы из JSON.


## <a name="related-links"></a>Связанные ссылки

- [Презентация - Мигель de Icaza создает на экран входа iOS с MonoTouch.Dialog](http://youtu.be/3butqB1EG0c)
- [Презентация - легко создавать пользовательские интерфейсы iOS с помощью MonoTouch.Dialog](http://youtu.be/j7OC5r8ZkYg)
- [Пошаговое руководство. Создание приложения с помощью API элементов](~/ios/user-interface/monotouch.dialog/elements-api-walkthrough.md)
- [Пошаговое руководство. Создание приложения с помощью API отражения](~/ios/user-interface/monotouch.dialog/reflection-api-walkthrough.md)
- [Пошаговое руководство. Использование элемента JSON для создания пользовательского интерфейса](~/ios/user-interface/monotouch.dialog/json-element-walkthrough.md)
- [Разметка MonoTouch.Dialog JSON](~/ios/user-interface/monotouch.dialog/monotouch.dialog-json-markup.md)
- [Диалоговое окно MonoTouch на Github](https://github.com/migueldeicaza/MonoTouch.Dialog)
- [Ссылки на класс UITableViewController](http://developer.apple.com/library/ios/#DOCUMENTATION/UIKit/Reference/UITableViewController_Class/Reference/Reference.html)
- [Ссылки на класс UINavigationController](http://developer.apple.com/library/ios/#documentation/UIKit/Reference/UINavigationController_Class/Reference/Reference.html)
