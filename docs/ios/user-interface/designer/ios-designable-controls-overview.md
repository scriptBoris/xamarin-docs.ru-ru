---
title: Пользовательские элементы управления в конструкторе Xamarin для iOS
description: Конструктор Xamarin для iOS поддерживает отрисовки пользовательских элементов управления в проекте создаются или ссылка из внешних источников, таких как Store компонент Xamarin.
ms.prod: xamarin
ms.assetid: D8F07D63-B006-4050-9D1B-AC6FCDA71B99
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/22/2017
ms.openlocfilehash: c409fcc018379401c1ab40573495da12a8220c5a
ms.sourcegitcommit: a1a58afea68912c79d16a3f64de9a0c1feb2aeb4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2019
ms.locfileid: "55233670"
---
# <a name="custom-controls-in-the-xamarin-designer-for-ios"></a>Пользовательские элементы управления в конструкторе Xamarin для iOS

_Конструктор Xamarin для iOS поддерживает отрисовки пользовательских элементов управления в проекте создаются или ссылка из внешних источников, таких как Store компонент Xamarin._

Конструктор Xamarin для iOS — мощное средство для визуализации пользовательского интерфейса приложения и предоставляет поддержку для большинства операций ввода-вывода представлениях и контроллерах представлений редактирования WYSIWYG. Приложения также могут содержать пользовательские элементы управления, которые расширяют возможности приложения, созданные в iOS. Если такие настраиваемые элементы управления записываются с несколько рекомендаций, помните, они могут также должен быть обработан iOS Designer, предоставляя более широких возможностей редактирования. В этом документе рассматриваются эти рекомендации.

## <a name="requirements"></a>Требования

В области конструктора будет отображаться элемент управления, который соответствует следующим требованиям:

1.  Она является подклассом прямых или косвенных [UIView](xref:UIKit.UIView) или [UIViewController](xref:UIKit.UIViewController). Другие [NSObject](xref:Foundation.NSObject) подклассы будет отображаться в виде значка в области конструктора.
2.  Он имеет [RegisterAttribute](xref:Foundation.RegisterAttribute) открыть ее для Objective-C.
3.  Он имеет [необходимый конструктор IntPtr](~/ios/internals/api-design/index.md).
4.  Он либо реализует [IComponent](xref:System.ComponentModel.IComponent) интерфейс или имеет [DesignTimeVisibleAttribute](xref:System.ComponentModel.DesignTimeVisibleAttribute) присвоено значение True.

При их содержащий проект компилируется для симулятора, элементов управления, определенных в коде, которые соответствуют требованиям выше появится в конструкторе. По умолчанию все пользовательские элементы управления будут отображаться в **пользовательские компоненты** раздел **элементов**. Тем не менее [CategoryAttribute](xref:System.ComponentModel.CategoryAttribute) могут применяться класс пользовательского элемента управления, чтобы указать другой раздел.

Конструктор не поддерживает загрузку сторонних библиотек Objective-C.

## <a name="custom-properties"></a>Настраиваемые свойства

Свойство, объявленное в пользовательский элемент управления будет отображаться в панели «свойства», если выполняются следующие условия:

1.  Свойство имеет открытого метода получения и задания.
1.  Свойство имеет [ExportAttribute](xref:Foundation.ExportAttribute) , а также [BrowsableAttribute](xref:System.ComponentModel.BrowsableAttribute) присвоено значение True.
1.  Тип свойства является числовой тип, тип перечисления, string, bool, [SizeF](xref:System.Drawing.SizeF), [UIColor](xref:UIKit.UIColor), или [UIImage](xref:UIKit.UIImage). Этот список поддерживаемых типов может расширяться в будущем.


Свойство также может быть оформлен [DisplayNameAttribute](xref:System.ComponentModel.DisplayNameAttribute) указать метку, которая отображается для него на панели «Свойства».

## <a name="initialization"></a>Инициализация

Для `UIViewController` подклассов, следует использовать [ViewDidLoad](xref:UIKit.UIViewController.ViewDidLoad) метод для кода, который зависит от представления, созданные в конструкторе.

Для `UIView` и других `NSObject` подклассов, [AwakeFromNib](xref:Foundation.NSObject.AwakeFromNib) метод является рекомендуемым местом для инициализации пользовательского элемента управления после его загрузки из файла макета. Это так, как все настраиваемые свойства, заданные на панели «свойства» не будет установлен при запуске конструктора элемента управления, но они будут устанавливаться перед `AwakeFromNib` вызывается:


```csharp
[Register ("CustomView"), DesignTimeVisible (true)]
public class CustomView : UIView {

    public CustomView (IntPtr handle) : base (handle) { }

    public override void AwakeFromNib ()
    {
        // Initialize the view here.
    }
}
```

Если элемент управления также должен создаваться непосредственно из кода, можно создать метод, который содержит общий код инициализации, следующим образом:

```csharp
[Register ("CustomView"), DesignTimeVisible (true)]
public class CustomView : UIView {

    public CustomView (IntPtr handle) : base (handle) { }

    public CustomView ()
    {
        // Called when created from code.
        Initialize ();
    }

    public override void AwakeFromNib ()
    {
        // Called when loaded from xib or storyboard.
        Initialize ();
    }

    void Initialize ()
    {
        // Common initialization code here.
    }
}
```

## <a name="property-initialization-and-awakefromnib"></a>Свойства инициализации и AwakeFromNib

На время и место для инициализации конструируемого свойств в пользовательский компонент относительно не перезаписать значения, которые были заданы в конструкторе iOS следует соблюдать осторожность. Например выполните следующий код:

```csharp
[Register ("CustomView"), DesignTimeVisible (true)]
public class CustomView : UIView {
    
    [Export ("Counter"), Browsable (true)]
    public int Counter {get; set;}

    public CustomView (IntPtr handle) : base (handle) { }

    public CustomView ()
    {
        // Called when created from code.
        Initialize ();
    }

    public override void AwakeFromNib ()
    {
        // Called when loaded from xib or storyboard.
        Initialize ();
    }

    void Initialize ()
    {
        // Common initialization code here.
        Counter = 0;
    }
}
```

`CustomView` Компонентом `Counter` свойство, которое можно задать разработчиком внутри конструктора iOS. Тем не менее, независимо от того, какое значение установлено в конструкторе значение `Counter` свойство всегда будет иметь нуль (0). Далее описывается, почему это происходит:

-  Экземпляр `CustomControl` увеличивается из файла раскадровки.
-  Устанавливаются свойства, измененные в конструкторе iOS (например, если значением `Counter` для двух (2), например).
-  `AwakeFromNib` Метода и вызов компонента `Initialize` метод.
-  Внутри `Initialize` значение `Counter` свойство сброшено в ноль (0).


Чтобы устранить выше ситуации, инициализации `Counter` свойство в другом месте (например, в конструкторе компонента) или не переопределить `AwakeFromNib` метод и вызвать `Initialize` Если для компонента требуется дополнительная инициализация не за пределами что в настоящее время обрабатывается его конструкторов.

## <a name="design-mode"></a>Режим конструктора

В области конструктора пользовательского элемента управления должен соответствовать несколько ограничений:

-  Ресурсы пакета приложения не доступны в режиме конструктора. Образы доступны при загрузке с помощью [UIImage методы](xref:UIKit.UIImage) .
-  Асинхронные операции, например веб-запросов, не должны выполняться в режиме конструктора. Области конструктора не поддерживает анимацию или других асинхронных обновлений для элемента управления пользовательского интерфейса.


Можно реализовать пользовательский элемент управления [IComponent](xref:System.ComponentModel.IComponent) и использовать [DesignMode](xref:System.ComponentModel.ISite.DesignMode) свойство, чтобы определить его в рабочей области конструирования. В этом примере будет отображена надпись «Режим конструктора» на рабочую область конструирования и «Runtime» во время выполнения:

```csharp
[Register ("DesignerAwareLabel")]
public class DesignerAwareLabel : UILabel, IComponent {

    #region IComponent implementation

    public ISite Site { get; set; }
    public event EventHandler Disposed;

    #endregion

    public DesignerAwareLabel (IntPtr handle) : base (handle) { }

    public override void AwakeFromNib ()
    {
        if (Site != null &amp;&amp; Site.DesignMode)
            Text = "Design Mode";
        else
            Text = "Runtime";
    }
}
```

Всегда следует выполнять проверку `Site` свойство для `null` прежде чем пытаться получить доступ к любой из его элементов. Если `Site` является `null`, безопасно предположить, элемент управления не работает в конструкторе.
В режиме конструктора `Site` устанавливается после запуска конструктора элемента управления и перед `AwakeFromNib` вызывается.

## <a name="debugging"></a>Отладка

Элемент управления, который соответствует требованиям выше отображаются на панели элементов и подготовке к просмотру в рабочей области.
Если элемент управления не отображается, проверьте наличие ошибок в элемент управления или один из ее зависимостей.

В область конструктора, часто можно перехватить исключения, создаваемые отдельных элементов управления при этом продолжать отображать другие элементы управления. Неисправный элемент управления заменяется red заполнитель, а Трассировка исключения можно просмотреть, щелкнув значок с восклицательным знаком:

 ![](ios-designable-controls-overview-images/exception-box.png "Неисправный элемент управления как красный заполнителя и сведения об исключении")

Если отладочные символы доступны для элемента управления, трассировка будет иметь имена файлов и номеров строк. Дважды щелкнув строку в трассировке стека будет выполнен переход на эту строку в исходном коде.

Если конструктор не может определить неисправный элемент управления, в верхней части области конструктора появится предупреждающее сообщение:

 ![](ios-designable-controls-overview-images/info-bar.png "Предупреждающее сообщение в верхней части области конструктора")

Полной подготовки к просмотру возобновится, когда неисправный элемент управления имеет фиксированную длину или удалены из рабочей области конструирования.

## <a name="summary"></a>Сводка

В этой статье представлен Создание и применение пользовательских элементов управления в конструктор iOS. Сначала он описываются требования, которым должны соответствовать элементы управления для отображения в области конструктора и предоставляющих настраиваемые свойства на панели «Свойства». Затем он рассмотрели кода программной части - инициализации элемента управления и свойство DesignMode. Наконец он описано, что происходит, когда возникают исключения и способы решения этой проблемы.