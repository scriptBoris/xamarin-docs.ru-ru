---
title: Введение в раскадровки в Xamarin.iOS
description: Этот документ содержит введение в раскадровки в Xamarin.iOS. Он описывает использование раскадровки для определения пользовательского интерфейса, однако они плохо и как использовать конструктор iOS для редактирования файлов раскадровки.
ms.prod: xamarin
ms.assetid: A3339BD2-9F56-7965-25F5-4B7C991EB775
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/22/2017
ms.openlocfilehash: 6294d696fe309e1952124caaaace89d40ad24bc6
ms.sourcegitcommit: a1a58afea68912c79d16a3f64de9a0c1feb2aeb4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2019
ms.locfileid: "55233566"
---
# <a name="introduction-to-storyboards-in-xamarinios"></a>Введение в раскадровки в Xamarin.iOS

В этом руководстве мы расскажем, какие раскадровки — и изучить некоторые из ключевых компонентов — например Segues. Мы рассмотрим как раскадровки можно создавать и использовать, и какие преимущества они имеют для разработчика.

Прежде, чем формат файла раскадровки был предложен компанией Apple визуальное представление пользовательского интерфейса приложения iOS, разработчики созданы XIB-файлы для каждого контроллера представления и вручную программировать переходы между каждого представления.  С помощью раскадровки позволяет разработчику определить контроллеры представлений и переходов между ними на поверхности разработки и предлагает редактирования WYSIWYG ПЛАТФОРМА пользовательского интерфейса приложения.

Раскадровки можно создать, открыть и редактировать в конструкторе IOS Xamarin. В этом руководстве также будет пошаговое руководство как использовать конструктор для создания собственных раскадровок при использовании C# для программирования панели навигации.


## <a name="requirements"></a>Требования

Раскадровки можно использовать с помощью iOS Designer в Visual Studio для Mac или Visual Studio 2015 и 2017 с рабочей нагрузки Xamarin.

## <a name="what-is-a-storyboard"></a>Что такое раскадровка?

Раскадровка — это визуальное представление всех экранов в приложении. В нем содержится последовательность сцен с каждый сцены из которых представляет *контроллер представления* и его *представления*. Эти представления могут содержать объекты и [элементов управления](~/ios/user-interface/controls/index.md) , будет разрешить пользователям взаимодействовать с приложением. Эта коллекция представлений и элементов управления (или *вложенных представлений*) называется *иерархии представлений содержимого*. Автоматически подключены по segue объекты, которые представляют переход между контроллерами представления. Обычно это достигается путем создания перехода между объектом в первоначальном представлении и представлении подключения. На рисунке ниже показаны связи в области конструктора:

 [![](images/storyboardsview.png "Связи в области конструктора показаны следующим образом:")](images/storyboardsview.png#lightbox)

Как показано, раскадровки будет разместить каждый из вашей сцены с содержимым уже отображен и показаны соединения между ними.  Стоит отметить, что когда мы говорим о сцены на iPhone, это уверенностью предположить, что один *сцены* на раскадровке равен одному *экрана* содержимого на устройстве. Тем не менее iPad, можно иметь сцены отображаться за один раз — к примеру, используют контроллер представления контекстном.

Есть много преимуществ с помощью раскадровки для создания пользовательского интерфейса приложения, особенно в том случае, если с помощью Xamarin. Во-первых, это визуальное представление пользовательского интерфейса, как все объекты — включая [пользовательские элементы управления](~/ios/user-interface/designer/ios-designable-controls-overview.md) — подготавливаются к просмотру во время разработки. Это означает, что перед построением или развертывание приложения, вы можете визуализировать его внешний вид и потока. Возьмем для примера приведенном выше рисунке. Мы можем сказать из краткий обзор проектирования, являются поверхности сколько сцены, макет каждого представления и все, что связь. Именно это и делает такой мощной раскадровки.

События являются более управляемыми с помощью раскадровок, особенно при использовании конструктора iOS. Большинство элементов управления пользовательского интерфейса получит список возможных событий в панели свойств. Обработчик событий, которые могут быть добавлены здесь и заполнять разделяемого метода в класс контроллеров представления...

Содержание раскадровки хранится в виде XML-файла. Во время, построения любой `.storyboard` файлы компилируются в двоичные файлы, известный как nibs. Во время выполнения эти nibs инициализируются и создать новые представления экземпляры.

## <a name="segues"></a>Однако они плохо

Объект *Segue*, или *объекта Segue*, используемую для представления переход между сценами разработки приложений для iOS. Чтобы создать переход, удерживайте нажатой **Ctrl** ключ, щелкните и перетащите от сцены, в другой. Мы перетаскивании наших мыши, появится голубой соединитель, показывающее, где будет привести переход, как показано на рисунке ниже:

 [![](images/createsegue.png "Голубой соединитель, показывающей, где будет привести переход, как показано на этом рисунке")](images/createsegue.png#lightbox)

На доступ к мыши появится меню нам выбрать действия для наших перехода. Это может выглядеть приведенные ниже изображения: 

**Pre-iOS 8 и классы размера**

[![](images/segue1.png "В раскрывающемся списке Action Segue без классы размера")](images/segue1.png#lightbox)

**При использовании классов размера и адаптивных сегментов**

[![](images/16new.png "Action Segue раскрывающийся список с помощью классов размера")](images/16new.png#lightbox)

> [!IMPORTANT]
> Если вы используете VMWare для виртуальной машины Windows, Ctrl + щелчок сопоставляется как _щелкните правой кнопкой мыши_ кнопку мыши по умолчанию. Для создания объекта перехода, изменить параметры клавиатуры через **предпочтения** > **клавиатуру и мышь** > **клавиш мыши** и повторное сопоставление вашей **Дополнительную кнопку** как показано ниже:
> 
> [![](images/image22.png "Настройки клавиатуры и мыши")](images/image22.png#lightbox)
> 
> Теперь можно добавить переход между контроллерами представления, в обычном режиме.

Существуют различные виды переходы, каждый даст контролировать способ представления нового контроллера представления для пользователя, и как она взаимодействует с другими контроллерами представления в раскадровке. Они описаны ниже. Можно также создать подкласс объект перехода, чтобы реализовать пользовательский переход:

-  **Показать / Push** — Принудительная отправка segue добавляет контроллера представления в стек навигации. Предполагается, что контроллер представления, рассчитанные на Push-уведомления входит в тот же контроллер навигации как контроллер представления, который добавляется в стек. Это делает то же самое `pushViewController` и обычно используется при наличии определенные связи между данными на экранах. С помощью Push-уведомления segue позволяет роскошь панель навигации с помощью кнопки "Назад" и title, добавляемые в каждое представление в стеке, позволяя детализации углублением навигации по иерархии представления.
-  **Модальное** — модального перехода создать связь между какие-либо контроллеры два представления в проекте, с возможностью анимированный переход отображаются. Контроллер представления дочерних полностью скроет контроллера представления родительского при принесено в представление. В отличие от push перехода, который добавляет кнопки "Назад" для нас; Если с помощью модального перехода `DismissViewController` должен использоваться для возврата к предыдущей контроллера представления.
-  **관습** - 모든 맞춤 segue는의 하위 클래스로 만들 수 있습니다 ` UIStoryboardSegue`.
-  **풀다** - 예를 들어 모달로 표시된보기 컨트롤러를 닫음으로써 푸시 또는 모달보기를 통해 뒤로 탐색하는 데 unwind segue를 사용할 수 있습니다. Кроме того можно развернуть через не только один, но серию Push-уведомлений и модальное окно переходы и вернуться назад, что действие очистки несколько шагов в иерархии навигации с одним. Чтобы понять, как использовать Очистка перехода в iOS, чтение [Создание очистки переходами](https://github.com/xamarin/recipes/tree/master/Recipes/ios/general/storyboard/unwind_segue) рецепт.
-  **Переход без источника** — sourceless segue указывает сцены, содержащий начальное представление-контроллер, и поэтому вид пользователь, который сначала увидят. Он представлен перехода, показано ниже:  

    [![](images/sourcelesssegue.png "Sourceless segue")](images/sourcelesssegue.png#lightbox)

### <a name="adaptive-segue-types"></a>Адаптивный Segue типы

 iOS 8 появился [классы размера](~/ios/user-interface/storyboards/unified-storyboards.md#size-classes) файла раскадровки iOS для работы с всех размеров экрана, позволяя разработчикам для создания одного пользовательского интерфейса для всех устройств iOS. По умолчанию все новые приложения Xamarin.iOS будет использовать классы размера. Использовать размер классы из старого проекта, см. в статье [Знакомство с унифицированным раскадровкам](~/ios/user-interface/storyboards/unified-storyboards.md) руководства. 
 
Любое приложение, с помощью классов размера также будет использоваться новый [ *адаптивной переходами*](~/ios/user-interface/storyboards/unified-storyboards.md). При использовании классов размера, помните, что мы не прямом указании допускает мы используем iPhone или iPad. Другими словами, мы создаем один пользовательский Интерфейс, который всегда будут выглядеть одинаково, независимо от того, сколько недвижимости, он должен работать с. Адаптивная рабочих Segues, судя среды и определяется наилучший способ представления содержимого. Адаптивная переходами, показаны ниже: 

[![](images/adaptivesegue.png "В раскрывающемся списке адаптивной переходами")](images/adaptivesegue.png#lightbox)

|Segue|Описание:|
|--- |--- |
|Показать|Это очень похоже на Push-уведомления segue, но необходимое содержимое экрана в учетную запись.|
|Показать подробности|Если в приложении отображаются основные и подробные представления (например, в контроллер разделенного представления на iPad), содержимое заменяет представлении «Подробности». Если в приложении отображается только основной или подробности, содержимое заменяет вершину стека контроллера представления.|
|Presentation|Это аналогично модального перехода и позволяет выбирать один из стилей представления и перехода.|
|Контекстном презентации|Это представляет содержимое в виде контекстном|

### <a name="transferring-data-with-segues"></a>Передача данных с переходами

Преимущества перехода не заканчиваться переходов. Они также могут использоваться для управления передачей данных между контроллерами представления. Это достигается путем переопределения `PrepareForSegue` метод на контроллере первоначального представления и обработки данных сами. При активации переход — например, с нажатие кнопки — приложение будет вызывать этот метод, он обеспечивает возможность подготовить новый контроллер представления *перед* происходит любые переходы. Приведенный ниже код, из [Phoneword](https://developer.xamarin.com/samples/monotouch/Hello_iOS/) пример, демонстрирует это: 


```csharp
public override void PrepareForSegue (UIStoryboardSegue segue, 
NSObject sender)
{
    base.PrepareForSegue (segue, sender);

    var callHistoryController = segue.DestinationViewController 
                                  as CallHistoryController;

    if (callHistoryController != null) {
        callHistoryController.PhoneNumbers = PhoneNumbers;
    }
}
```

В этом примере `PrepareForSegue` метод будет вызываться при активации пользователем переход. Сначала нам нужно создать экземпляр «принимающей» контроллер представления и настройте его как перехода целевой контроллер представления. Это делается с помощью строки кода ниже:

```csharp
var callHistoryController = segue.DestinationViewController as CallHistoryController;
```

Метод теперь имеет возможность задать свойства `DestinationViewController`. В этом примере мы использовали это, передавая список, который называется `PhoneNumbers` для `CallHistoryController` и назначьте ей объект с тем же именем:

```csharp
if (callHistoryController != null) {
        callHistoryController.PhoneNumbers = PhoneNumbers;
    }
```

После завершения перехода, пользователь увидит `CallHistoryController` с заполненного списка.

## <a name="adding-a-storyboard-to-a-non-storyboard-project"></a>Добавление в проект без использования Storyboard раскадровки

В некоторых случаях может потребоваться добавить раскадровку в файл ранее раскадровки. После этого в Visual Studio для Mac можно упростить, выполнив следующие действия:

# <a name="visual-studio-for-mactabmacos"></a>[Visual Studio для Mac](#tab/macos)

1. Создайте новый файл раскадровки, перейдя по адресу **файл > новый файл > iOS > раскадровки**, как показано ниже: 
    
    [![](images/new-storyboard-xs.png "Диалоговое окно создания файла")](images/new-storyboard-xs.png#lightbox)

2. Добавьте свое имя раскадровки, чтобы **главный интерфейс** раздел **Info.plist**, как показано ниже:
    
    [![](images/infoplist.png "В редакторе Info.plist")](images/infoplist.png#lightbox)
    
    Это делает то же самое создания начальным контроллером представления в `FinishedLaunching` метода в делегате приложения. С таким параметром, приложение создает экземпляр окна (см. ниже), загружает основной раскадровки и назначает ему экземпляр начальным контроллером представления раскадровки (тот, рядом с sourceless Segue) в качестве `RootViewController` свойство окна, а затем делает отображается окно на экране.

3. В `AppDelegate`, переопределить значение по умолчанию `Window` метод необходимо реализовать свойство окне следующим кодом:
        
        public override UIWindow Window {
            get;
            set;
            }
            
# <a name="visual-studiotabwindows"></a>[Visual Studio](#tab/windows)

1. Создайте новый файл раскадровки, щелкнув правой кнопкой проект, чтобы **Добавить > новый файл > iOS > пустую раскадровку**, как показано ниже: 
    
    [![](images/new-storyboard-vs.png "В диалоговом окне создания элемента")](images/new-storyboard-vs.png#lightbox)

2. Добавьте свое имя раскадровки, чтобы **главный интерфейс** раздел iOS приложения, как показано ниже:
    
    [![](images/ios-app.png "В редакторе Info.plist")](images/ios-app.png#lightbox)
    
    Это делает то же самое создания начальным контроллером представления в `FinishedLaunching` метода в делегате приложения. С таким параметром, приложение создает экземпляр окна (см. ниже), загружает основной раскадровки и назначает ему экземпляр начальным контроллером представления раскадровки (тот, рядом с sourceless Segue) в качестве `RootViewController` свойство окна, а затем делает отображается окно на экране.

3. В `AppDelegate`, переопределить значение по умолчанию `Window` метод необходимо реализовать свойство окне следующим кодом:

        public override UIWindow Window {
            get;
            set;
            }
            
-----

## <a name="creating-a-storyboard-with-the-ios-designer"></a>Создание раскадровки в конструкторе IOS

Раскадровки могут создаваться с помощью конструктора Xamarin для iOS, который были интегрируется с Visual Studio для Mac и Visual Studio.

Чтобы начать работу с помощью iOS Designer для создания раскадровки, выполните [Привет, iOS (несколько экранов)](~/ios/get-started/hello-ios-multiscreen/index.md) руководства. В этом пошаговом руководстве будет изучено навигации между контроллерами представления, используя Segues и порядок обработки событий для элементов управления.

## <a name="instantiate-storyboards-manually"></a>Создать экземпляр раскадровки вручную

Раскадровки полностью заменить отдельные файлы XIB в проекте, но контроллеры отдельные представления в раскадровке по-прежнему могут создаваться с помощью `Storyboard.InstantiateViewController`.

Иногда приложения нет особых требований, которые не могут быть обработаны с переходами встроенные раскадровки, предоставленный конструктором. Например если требуется создать приложение, которое запускает различные экраны с помощью одной кнопки, в зависимости от текущего состояния приложения, мы может потребоваться вручную создать экземпляр контроллеры представлений и программировать перехода, сами.

На следующем снимке экрана показано, что два контроллера представления в нашей конструктора нет перехода между ними. Следующий раздел поможет выполнить как этот переход можно настроить в коде.

 [![](images/viewcontrollerspink.png "На этом снимке экрана показано, что два контроллера представления в рабочей области конструирования не имеющий перехода между ними")](images/viewcontrollerspink.png#lightbox)

1. Добавить _пустая раскадровка iPhone_ в существующий проект проекта:
    
    [![](images/add-storyboard1.png "Добавление раскадровки")](images/add-storyboard1.png#lightbox)

2. Дважды щелкните только что созданный раскадровки, чтобы открыть его и добавьте новую **контроллер навигации** в область конструктора. Как контроллер навигации — без интерфейса пользователя, по умолчанию, он будет иметь корневой контроллер представления, как показано ниже:

    [![](images/uinavigationcontroller.png "Контроллеры представлений с переходами")](images/uinavigationcontroller.png#lightbox)

3. Выберите _контроллер представления_ , щелкнув черную полосу в нижней. В конструкторе **панели свойство**в разделе **удостоверений** можно указать пользовательский класс, а также уникальный идентификатор для контроллера представления. Задайте **имя класса** и **идентификатора раскадровки** для `MainViewController`.

    [![](images/identitypanelnew.png "Укажите пользовательский класс")](images/identitypanelnew.png#lightbox)

4. Позже, необходимо создать экземпляр нашей контроллеров представлений из раскадровки и будет использовать идентификатор раскадровки, чтобы ссылаться на них в коде. Задание идентификатора восстановления идентификатор раскадровки гарантирует, что правильно контроллера представления получает повторно, если необходимо восстановить состояние.

5. Мы сейчас иметь только один контроллер представления. Перетащите другой контроллер представления в область конструктора. В **панели свойство**, удостоверением, задайте класса и идентификатор раскадровки для `PinkViewController`, как показано ниже:

    [![](images/pinkvcnew.png "На панели свойств")](images/pinkvcnew.png#lightbox)
    
    IDE создаст эти пользовательские классы для представления контроллеров. Их можно просмотреть в **панели решения**, как показано на следующем снимке экрана:
    
    [![](images/solution-pad.png "Панель решения")](images/solution-pad.png#lightbox)

6. В `PinkViewController`, выберите представление, щелкнув к центру контроллера кадра. В панели свойств в представление измените **фона** для пурпурный:
    
    [![](images/pinkcontroller.png "Задайте цвет фона")](images/pinkcontroller.png#lightbox)

7. Наконец, перетащите кнопку из **элементов** на `MainViewController`. В панели свойств, присвойте ему имя `PinkButton` и GoToPink Title, как показано ниже:

    [![](images/pinkbutton.png "Задайте имя кнопки")](images/pinkbutton.png#lightbox)

Раскадровка завершена, но если мы теперь развертывание проекта, мы получаем пустой экран. Том, что мы по-прежнему должны сообщить интегрированной среды разработки для использования наших раскадровки и настраивать корневой контроллер представления для использования в качестве первое представление. Обычно это можно сделать через наши параметров проекта, как показано выше. Тем не менее в этом примере мы выполним достигается тот же результат, в коде, добавив следующую строку **AppDelegate**:

```csharp
public partial class AppDelegate : UIApplicationDelegate
    {
        UIWindow window;
        public static UIStoryboard Storyboard = UIStoryboard.FromName ("MainStoryboard", null);
        public static UIViewController initialViewController;

        public override bool FinishedLaunching (UIApplication app, NSDictionary options)
        {
            window = new UIWindow (UIScreen.MainScreen.Bounds);

            initialViewController = Storyboard.InstantiateInitialViewController () as UIViewController;

            window.RootViewController = initialViewController;
            window.MakeKeyAndVisible ();
            return true;
        }

    }
```

Большой объем кода, но лишь несколько строк не знакомы. Во-первых, мы регистрируем наш раскадровки с **AppDelegate** , передав имя раскадровки, **MainStoryboard**. Затем мы указываем приложение для создания экземпляра контроллера первоначального представления из раскадровки, вызвав `InstantiateInitialViewController` на наших раскадровки и задать в качестве корневого контроллера представления наше приложение, контроллер представления мы. Этот метод определяет первый экран, который видит пользователь, и создает новый экземпляр этого контроллера представления.

Обратите внимание, что в панели решения, который создан интегрированной среды разработки `MainViewcontroller.cs` класс и его `corresponding designer.cs` когда мы добавили имя класса на панели свойств на шаге 4. Мы видим, этот класс создан специальный конструктор, который включает в себя базовый класс:

```csharp
public MainViewController (IntPtr handle) : base (handle) 
{
}
```


При создании раскадровки, с помощью конструктора, интегрированная среда разработки автоматически добавит [[регистрация]](xref:Foundation.RegisterAttribute) атрибут в верхней части `designer.cs` и передайте идентификатор строки, которое идентично идентификатора раскадровки, указанных в предыдущий шаг. Это свяжет C# в соответствующие сцену в раскадровке.

В определенный момент, может потребоваться добавить существующий класс, который был **не** созданные в конструкторе. В этом случае необходимо зарегистрировать этот класс в обычном режиме:

```csharp
[Register ("MainViewController")]
public partial class MainViewController : UIViewController
{
public MainViewController (IntPtr handle) : base (handle) 
{
}

...
}
```

Дополнительные сведения о регистрации классов и методов, см. [тип регистратора](http://docs.xamarin.com/guides/ios/advanced_topics/registrar/) документации.

Последним шагом в этом классе является привязывания кнопки и переход на контроллер представления розовый. Мы будем создавать экземпляры `PinkViewController` из раскадровки; затем мы используем будет при программировании push перехода с `PushViewController`, как показано в следующем примере кода:

```csharp
public partial class MainViewController : UIViewController
{
    UIViewController pinkViewController;

    public MainViewController (IntPtr handle) : base (handle)
    {

    }

    public override void AwakeFromNib ()
    {
    // Called when loaded from xib or storyboard.

    this.Initialize ();
    }

    public void Initialize(){

    //Instantiating View Controller with Storyboard ID 'PinkViewController'
    pinkViewController = Storyboard.InstantiateViewController ("PinkViewController") as PinkViewController;
    }

    public override void ViewDidLoad ()
    {
    base.ViewDidLoad ();

    //When we push the button, we will push the pinkViewController onto our current Navigation Stack
    PinkButton.TouchUpInside += (o, e) =&gt; {
        this.NavigationController.PushViewController (pinkViewController, true);
    };
    }

}
```

Запуск приложения создается приложение 2 экран:

![](images/finishedstoryboard.png "Экраны запуска примера приложения")

## <a name="conditional-segues"></a>Однако они плохо Conditional

Часто переход от одного контроллера представления к другому зависит от определенного условия. Например, если мы вносим экран входа простой мы только целесообразно для перемещения к следующему экрану *Если* проверено имя пользователя и пароль.

В следующем примере мы добавим поле пароля в приведенном выше примере. Пользователь будет только для доступа к *PinkViewController* в случае ввода правильного пароля, в противном случае ошибка будет отображаться.

Прежде чем начать, выполните шаги 1 – 8 выше. В этом пошаговом руководстве мы создания нашей раскадровки, начать создание пользовательскому Интерфейсу и сообщить какой контроллер представления для использования наших делегата приложения как RootViewController.

1. Теперь давайте создадим наш пользовательский интерфейс и добавить дополнительные представления, перечисленные в `MainViewController` чтобы это выглядело как тот, на следующем снимке экрана:

    - UITextField
        - Имя. PasswordTextField
        - Заполнитель: «Введите секретный пароль»
    - UILabel
        - Text: "Ошибка: Неверный пароль. Не должен проходить! "
        - Цвет: Красный
        - Выравнивание: Центр
        - Строки: 2
        - Флажок «Скрытый» 
        
    [![](images/passwordvc.png "Центр строки")](images/passwordvc.png#lightbox)
    
2. Создайте переход между перейдите к розовый кнопки и контроллера представления, перетащив Ctrl из *PinkButton* для *PinkViewController*и выбрав **Push** на доступ к мыши . 

3. Щелкните переход и присвойте ему *идентификатор* `SegueToPink`:

    [![](images/namesegue.png "Щелкните переход и присвойте ему идентификатор SegueToPink")](images/namesegue.png#lightbox)  
    

4. Наконец, добавьте следующий метод ShouldPerformSegue `MainViewController` класса:

    ```csharp
    public override bool ShouldPerformSegue (string segueIdentifier, NSObject sender)
    {
        
        if(segueIdentifier == "SegueToPink"){
            if (PasswordTextField.Text == "password") {
                PasswordTextField.ResignFirstResponder ();
                return true;
            }
            else{
                ErrorLabel.Hidden = false;
                return false;
            }
        }
        return base.ShouldPerformSegue (segueIdentifier, sender);
    }
    ```

В этом коде мы объединили segueIdentifier для наших `SegueToPink` перехода, поэтому мы затем можно проверить условие; допустимый пароль в данном случае. Если наш условие возвращает `true`, выполнит переход и представит `PinkViewController`. Если `false`, не будут отображаться на новом контроллере представления.

Мы применяем этот подход для любой переход на этом контроллере представления путем проверки segueIdentifier аргумент метода ShouldPerformSegue. В этом случае у нас имеется только один идентификатор перехода — `SegueToPink`.

См. в решение Storyboards.Conditional [пример раскадровки вручную](https://developer.xamarin.com/samples/monotouch/ManualStoryboard/) рабочий пример.

<a name="Using-Storyboard-References" />

## <a name="using-storyboard-references"></a>С помощью ссылки раскадровки

Ссылки раскадровки позволяет принимать большие и сложные макета раскадровки, разбив его на небольших раскадровки, получение ссылки из исходного, таким образом удаление сложности и упрощение разработки и обслуживания итоговый отдельных раскадровок.

Кроме того, можно предоставить ссылку на раскадровку _привязки_ другой сцену в одной раскадровке или конкретных сцены на другом.

<a name="Referencing-an-External-Storyboard" />

### <a name="referencing-an-external-storyboard"></a>Ссылки на внешние раскадровки

Чтобы добавить ссылку на внешний раскадровки, сделайте следующее:

1. В **обозревателе решений**, щелкните правой кнопкой мыши имя проекта и выберите **добавить** > **новый файл...**   >  **iOS** > **раскадровки**. Введите **имя** новой раскадровки и нажмите кнопку **New** кнопки:
    
    [![](images/ref01.png "Диалоговое окно создания файла")](images/ref01.png#lightbox)
    
2. Разработка макета новая раскадровка автоматически, как обычно и сохраните изменения: 
    
    [![](images/ref02.png "Макет новой сцены")](images/ref02.png#lightbox)
    
3. Откройте раскадровку, нужно добавления ссылки в конструкторе iOS.

4. Перетащите **раскадровка ссылку** из **элементов** в область конструктора: 
    
    [![](images/ref03.png "Ссылки раскадровки")](images/ref03.png#lightbox)
    
5. В **мини-приложение** вкладке **обозревателе свойств**, выберите имя **раскадровки** , созданный выше: 

    [![](images/ref04.png "На вкладке мини-приложения")](images/ref04.png#lightbox)
    
6. Элемент управления, щелкните пользовательский Интерфейс мини-приложения (например, кнопки) на существующий сцены и создайте новый переход к **ссылки раскадровки** только что созданный: 

    [![](images/ref05.png "Создание объекта перехода")](images/ref05.png#lightbox) 
    
7. Во всплывающем меню выберите **Показать** для завершения перехода: 

    [![](images/ref06.png "Выбрав Show, чтобы завершить переход")](images/ref06.png#lightbox) 
    
8. Сохраните изменения в раскадровку.

Будет отображаться при запуске приложения, и пользователь щелкает элемент пользовательского интерфейса, созданного переход с начальным контроллером представления из внешних раскадровки, указанный в ссылке раскадровки.

<a name="Referencing-a-Specific-Scene-in-an-External-Storyboard" />

### <a name="referencing-a-specific-scene-in-an-external-storyboard"></a>Ссылки на определенные сцены в раскадровке внешних

Для добавления ссылки на определенные сцены внешних раскадровки (и не начальным контроллером представления), сделайте следующее:

1. В **обозревателе решений**, дважды щелкните внешних раскадровки, чтобы открыть его для редактирования.

2. Добавьте новую сцену и его макет, как обычно: 

    [![](images/ref07.png "Новый макет сцены")](images/ref07.png#lightbox)
    
3. В **мини-приложение** вкладке **обозревателе свойств**, введите **идентификатора раскадровки** для новой сцены контроллера представления: 

    [![](images/ref08.png "Введите идентификатор раскадровки для нового контроллера представления для сцены")](images/ref08.png#lightbox)
    
3. Откройте раскадровку, нужно добавления ссылки в конструкторе iOS.

4. Перетащите **раскадровка ссылку** из **элементов** в область конструктора: 

    [![](images/ref03.png "Ссылки раскадровки")](images/ref03.png#lightbox)
    
5. В **мини-приложение** вкладке **обозревателе свойств**, выберите имя **раскадровки** и **идентификатор ссылки** (идентификатор раскадровки) из Сцены, созданный выше: 

    [![](images/ref09.png "На вкладке мини-приложения ")](images/ref09.png#lightbox)
    
6. Элемент управления, щелкните пользовательский Интерфейс мини-приложения (например, кнопки) на существующий сцены и создайте новый переход к **ссылки раскадровки** только что созданный: 

    [![](images/ref10.png "Создание объекта перехода")](images/ref10.png#lightbox) 
    
7. Во всплывающем меню выберите **Показать** для завершения перехода: 

    [![](images/ref06.png "Выбрав Show, чтобы завершить переход")](images/ref06.png#lightbox) 
    
8. Сохраните изменения в раскадровку.

Если приложение — выполнения, а пользователь щелкнет элемент пользовательского интерфейса, который вы создали переход из жестких дисков с данной **идентификатора раскадровки** из внешних раскадровки, указанный в ссылке раскадровки будет отображаться.

<a name="Referencing-a-Specific-Scene-in-the-Same-Storyboard" />

### <a name="referencing-a-specific-scene-in-the-same-storyboard"></a>Ссылки на определенные сцены в одной раскадровке

Чтобы добавить ссылку на конкретных сцены же раскадровки, сделайте следующее:

1. В **обозревателе решений**, дважды щелкните файл раскадровки, чтобы открыть его для редактирования.

2. Добавьте новую сцену и его макет, как обычно: 

    [![](images/ref11.png "Новый макет сцены")](images/ref11.png#lightbox)

3. В **мини-приложение** вкладке **обозревателе свойств**, введите **идентификатора раскадровки** для новой сцены контроллера представления: 

    [![](images/ref12.png "На вкладке мини-приложения")](images/ref12.png#lightbox)
    
3. Перетащите **раскадровка ссылку** из **элементов** в область конструктора: 

    [![](images/ref03.png "Ссылки раскадровки")](images/ref03.png#lightbox)
    
5. В **мини-приложение** вкладке **обозревателе свойств**выберите **идентификатор ссылки** (идентификатор раскадровки) сцены, созданный выше: 

    [![](images/ref13.png "На вкладке мини-приложения")](images/ref13.png#lightbox)
    
6. Элемент управления, щелкните пользовательский Интерфейс мини-приложения (например, кнопки) на существующий сцены и создайте новый переход к **ссылки раскадровки** только что созданный: 

    [![](images/ref14.png "Создание объекта перехода")](images/ref14.png#lightbox) 
    
7. Во всплывающем меню выберите **Показать** для завершения перехода: 

    [![](images/ref06.png "Выбрав Show, чтобы завершить переход")](images/ref06.png#lightbox) 
    
8. Сохраните изменения в раскадровку.

Если приложение — выполнения, а пользователь щелкнет элемент пользовательского интерфейса, который вы создали переход из жестких дисков с заданной **идентификатора раскадровки** в одной раскадровке, указанный в ссылке раскадровки будет отображаться.

## <a name="summary"></a>Сводка

В этой статье рассматриваются концепции раскадровки и как они могут быть полезны при разработке приложений iOS. В нем описывается сцены, контроллеров представлений, представлений и иерархий представлений и как сцены связаны вместе с различными типами Segues.  Она также изучает создания экземпляров контроллеров представлений вручную из раскадровки, а создание условного Segues.



## <a name="related-links"></a>Связанные ссылки

- [Ручная раскадровка (образец)](https://developer.xamarin.com/samples/ManualStoryboard/)
- [Введение в iOS Designer](~/ios/user-interface/designer/introduction.md)
- [Преобразование в раскадровки](http://developer.apple.com/library/ios/#releasenotes/Miscellaneous/RN-AdoptingStoryboards/)
- [Справочник по классу UIStoryboard](https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIStoryboard_Class/Reference/Reference.html)
