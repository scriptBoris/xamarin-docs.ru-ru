---
title: Доступ к файловой системе в Xamarin.iOS
description: В этом документе описывается работа с файловой системой в Xamarin.iOS. Здесь рассматриваются каталоги, чтение файлов, сериализации XML и JSON, "песочница" приложений, совместное использование файлов с помощью iTunes и многое другое.
ms.prod: xamarin
ms.assetid: 37DF2F38-901E-8F8E-269A-5EE0CCD28C08
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 11/12/2018
ms.openlocfilehash: 38422682849de60a3f43e513ef48011d32b030ef
ms.sourcegitcommit: d09391c315336d36496880ef465a72b8974f2ac7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/13/2018
ms.locfileid: "51579873"
---
# <a name="file-system-access-in-xamarinios"></a>Доступ к файловой системе в Xamarin.iOS

[![Загрузить образец](~/media/shared/download.png) загрузить пример](https://developer.xamarin.com/samples/FileSystemSampleCode/)

Можно использовать Xamarin.iOS и `System.IO` классы в *библиотеки базовых классов (BCL) .NET* для доступа к файловой системе iOS. `File` Класс позволяет создавать, удалять и читать файлы и `Directory` класс позволяет создавать, удалять или перечислять содержимое каталогов. Можно также использовать `Stream` подклассов, которые может предоставить большую степень контроля над операции с файлами (например, сжатие или позицию поиска в файле).

iOS накладывает некоторые ограничения на приложения можно сделать с помощью файловой системы для обеспечения безопасности данных приложения и для защиты пользователей от malignant приложений. Эти ограничения являются частью *приложения "песочницы"* — набор правил доступа приложения к файлы, настройки, сетевые ресурсы, оборудования, и т.д. Приложение ограничено чтение и запись файлов в пределах его домашний каталог (расположения); он нет доступа к файлам других приложений.

iOS также есть некоторые возможности конкретной системы файл: некоторые каталоги требуют специальной обработки по отношению к резервное копирование и обновление, и приложения могут также совместно использовать файлы друг с другом и **файлы** приложения (начиная с iOS 11) и с помощью iTunes.

В этой статье рассматриваются функции и ограничения операций ввода-вывода файловой системы и включает пример приложения, которое демонстрирует, как использовать Xamarin.iOS для выполнения некоторых операций простой файловой системы:

[![Пример выполнения некоторых операций простой файловой системы iOS](file-system-images/01-sampleapp-sml.png)](file-system-images/01-sampleapp.png#lightbox)

## <a name="general-file-access"></a>Доступ к файлам, общие

Xamarin.iOS позволяет использовать .NET `System.IO` классы для операций файловой системы на устройствах iOS.

В следующих фрагментах кода показаны некоторые общие файловые операции. Вы найдете их все ниже в **SampleCode.cs** файла, в примере приложения для этой статьи.

### <a name="working-with-directories"></a>Работа с каталогами

Этот код перечисляет подкаталоги в текущем каталоге (указанного по «. /» параметр), — расположение исполняемого файла приложения.
Выходные данные будут представлять собой список все файлы и папки, которые развертываются с приложением (отображается в окне консоли при отладке).

```csharp
var directories = Directory.EnumerateDirectories("./");
foreach (var directory in directories) {
      Console.WriteLine(directory);
}
```

### <a name="reading-files"></a>Чтение файлов

Чтобы прочитать текстовый файл, требуется только одной строки кода. В этом примере содержимое текстового файла будет отображаться в окне выходных данных приложения.

```csharp
var text = File.ReadAllText("TestData/ReadMe.txt");
Console.WriteLine(text);
```

### <a name="xml-serialization"></a>сериализация XML

Несмотря на то, что работа с полный `System.Xml` пространство имен выходит за рамки данной статьи, их можно легко десериализовать XML-документа из файловой системы с помощью StreamReader, как и в этом фрагменте кода:

```csharp
using (TextReader reader = new StreamReader("./TestData/test.xml")) {
      XmlSerializer serializer = new XmlSerializer(typeof(MyObject));
      var xml = (MyObject)serializer.Deserialize(reader);
}
```

Дополнительные сведения см. в документации по [System.Xml](xref:System.Xml) и [сериализации](xref:System.Xml.Serialization). См. в разделе [документация по Xamarin.iOS](~/ios/deploy-test/linker.md) в строке компоновщика — часто будет необходимо добавить `[Preserve]` атрибут классы для сериализации.

### <a name="creating-files-and-directories"></a>Создание файлов и каталогов

В этом примере показано, как использовать `Environment` класс для доступа к папке «документы», где можно создать файлы и каталоги.

```csharp
var documents =
 Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments); 
var filename = Path.Combine (documents, "Write.txt");
File.WriteAllText(filename, "Write this text into a file");
```

Создание каталога является схожим процессом:

```csharp
var documents =
 Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var directoryname = Path.Combine (documents, "NewDirectory");
Directory.CreateDirectory(directoryname);
```

Дополнительные сведения см. в разделе [Справочник по System.IO API](xref:System.IO).

### <a name="serializing-json"></a>Сериализация JSON

[Json.NET](http://www.newtonsoft.com/json) — это платформа высокой производительности JSON, который работает с Xamarin.iOS и доступен в NuGet. Добавьте пакет NuGet для приложения проекта, с помощью **NuGet добавьте** в Visual Studio для Mac:

[![](file-system-images/json01.png "Добавление пакета NuGet в проект приложения")](file-system-images/json01.png#lightbox)

Добавьте класс в качестве модели данных для сериализации и десериализации (в данном случае `Account.cs`):

```csharp
using System;
using System.Collections.Generic;
using Foundation; // for Preserve attribute, which helps serialization with Linking enabled

namespace FileSystem
{
    [Preserve]
    public class Account
    {
        public string Email { get; set; }
        public bool Active { get; set; }
        public DateTime CreatedDate { get; set; }
        public List<string> Roles { get; set; }

        public Account() {
        }
    }
}
```

Наконец, создайте экземпляр `Account` класса, выполнить его сериализацию в данные json и записать их в файл:

```csharp
// Create a new record
var account = new Account(){
    Email = "monkey@xamarin.com",
    Active = true,
    CreatedDate = new DateTime(2015, 5, 27, 0, 0, 0, DateTimeKind.Utc),
    Roles = new List<string> {"User", "Admin"}
};

// Serialize object
var json = JsonConvert.SerializeObject(account, Newtonsoft.Json.Formatting.Indented);

// Save to file
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var filename = Path.Combine (documents, "account.json");
File.WriteAllText(filename, json);
```

Дополнительные сведения о работе с данными json в приложении .NET, см. в разделе Json .NET [документации](http://www.newtonsoft.com/json/help).

## <a name="special-considerations"></a>Специальные условия

Несмотря на схожесть Xamarin.iOS и .NET операций с файлами, iOS и Xamarin.iOS отличаются от .NET, в некоторых важных аспектах.

### <a name="making-project-files-accessible-at-runtime"></a>Доступности файлов проекта во время выполнения

По умолчанию при добавлении файла в проект, он не будут включены в окончательную сборку и таким образом, не будут доступны для приложения. Чтобы включить файл в сборку, необходимо отметить его с действием особой сборкой, «содержимое».

Чтобы пометить файл для включения, щелкните правой кнопкой мыши, файлов и выберите **действие при построении &gt; содержимого** в Visual Studio для Mac. Можно также изменить **действие при построении** в файле **свойства** таблицы стилей.

### <a name="case-sensitivity"></a>Учет регистра

Важно понимать, что файловая система iOS *с учетом регистра*. Учет регистра означает, что в имена файлов и каталогов должен соответствовать точно — **README.txt** и **readme.txt** будет считаться разные имена файлов.

Это может привести к сбоям для разработчиков .NET, которые знакомы с файловой системой Windows, который является *без учета регистра* — **файлы**, **файлы**, и  **файлы** ссылаетесь на том же каталоге.

> [!WARNING]
> Не в симуляторе iOS с учетом регистра.
> Если регистр в имени файла отличаются от самого файла и ссылки на него в коде, ваш код может по-прежнему работать в симуляторе, но его не удастся на реальных устройствах. Это одна из причин, почему это важно развернуть и протестировать на настоящем устройстве более ранней и часто во время разработки iOS.

### <a name="path-separator"></a>Разделитель пути

iOS для этого используется знак косой черты «/» как разделитель пути (который отличается от Windows, которая использует обратную косую черту "\").

Из-за этого отличия путаницу, рекомендуется использовать `System.IO.Path.Combine` метод, который настраивает для текущей платформы, а не следует жестко кодировать разделитель конкретного пути. Это простое действие, которое делает код более пригодным для переноса на другие платформы.

## <a name="application-sandbox"></a>Приложение "песочницы"

Доступ приложения к файловой системе (и другие ресурсы, такие как функции сети и оборудования) ограничена по соображениям безопасности. Это ограничение называется *приложения "песочницы"*. С точки зрения файловой системе приложение ограничено Создание и удаление файлов и каталогов в своем домашнем каталоге.

Корневой каталог — это уникальное расположение в файловой системе, где хранятся ваши приложения и все его данные. Нельзя выбрать (или изменить) расположение домашнего каталога для приложения; Тем не менее iOS и Xamarin.iOS предоставляют свойства и методы для управления файлами и каталогами внутри.

## <a name="the-application-bundle"></a>Пакет приложений

*Набор приложений* — папка, которая содержит приложение.
Он отличается от других папках, задав .app суффикс, добавляемый к имени каталога. Ваш пакет приложения содержит исполняемый файл и все содержимое (файлы, изображения, и т.д.) требуется для вашего проекта.

При переходе к вашего пакета приложения в Mac OS, он отображается другим значком не вы видите в других каталогах (и **.app** суффикс скрыт); тем не менее, это просто регулярных каталог, который отображает ОС по-разному.

Просмотр пакета приложения, для примера кода, щелкните правой кнопкой мыши проект в **Visual Studio для Mac** и выберите **отобразить в Finder**. Затем перейдите к **bin /** каталог, где вы должны найти значка приложения (как на снимке экрана ниже).

![Просмотрите каталог bin, чтобы найти примерно значка приложения](file-system-images/40-bundle.png)

Щелкните этот значок правой кнопкой мыши и выберите **Показать содержимое пакета** для просмотра содержимого каталога пакета приложения. Содержимое отображается так же, как содержимое регулярных каталога, как показано ниже:

[![Содержимое пакета приложения](file-system-images/45-bundle-sml.png)](file-system-images/45-bundle.png#lightbox)

— Пакет приложений, установленных в симуляторе или на устройстве во время тестирования, и в конечном счете это что отправляется в Apple для включения в App Store.

## <a name="application-directories"></a>Каталоги приложения

При установке приложения на устройстве, операционная система создает домашнего каталога для приложения и создает несколько каталогов в корневой каталог приложения, которые доступны для использования. С момента iOS 8, будут недоступны для пользователей каталогов [находятся](https://developer.apple.com/library/ios/technotes/tn2406/_index.html) в корне приложения, так что нельзя наследовать пути для пакета приложения из каталогов пользователя (или наоборот).

Эти каталоги, как определить пути к их и их назначение, перечислены ниже:

&nbsp;

|Каталог|Описание|
|---|---|
|.App [ApplicationName] /|**В iOS 7 и более ранних версий**, это `ApplicationBundle` каталог, где хранится исполняемый файл приложения. Структура каталогов, которая создается в приложении существует в этом каталоге (например, изображений и других типов файлов, которые вы пометили как ресурсы в Visual Studio для Mac проекта).<br /><br />Если вам требуется доступ к файлам содержимого внутри вашего пакета приложения, путь к этому каталогу доступен через `NSBundle.MainBundle.BundlePath` свойство.|
|Документы /|Используйте этот каталог для хранения пользовательские документы и файлы данных приложения.<br /><br />Содержимое этого каталога может предоставляться пользователю через iTunes файлам (несмотря на то, что эта функция отключена по умолчанию). Добавление `UIFileSharingEnabled` логический ключ в файле Info.plist, чтобы разрешить пользователям доступ к этим файлам.<br /><br />Даже если приложение не позволяет сразу же использовать общий доступ к файлам, следует избегать размещения файлов, которые должны быть скрыты от пользователей в этом каталоге (такие как файлы базы данных, если не требуется использовать их совместно). До тех пор, пока конфиденциальные файлы остаются скрытыми, эти файлы будут не доступны (и потенциально перемещен, измененные или удаленные, iTunes) при включении общего доступа к файлам в будущей версии.<br /><br /> Можно использовать `Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments)` метод, чтобы получить путь к каталогу документов для вашего приложения.<br /><br />Содержимое этого каталога резервное копирование по iTunes.|
|Библиотека /|Каталог библиотеки хорошо подходит для хранения файлов, которые не создаются непосредственно пользователем, например баз данных или другие файлы, создаваемые приложением. Содержимое этого каталога никогда не предоставляются пользователю через iTunes.<br /><br />Можно создать собственные подкаталоги в библиотеке. Тем не менее уже имеются некоторые созданные системой каталоги здесь, которые следует учитывать, включая предпочтения и кэши.<br /><br />Содержимое этого каталога (за исключением подкаталог кэшей) резервное копирование по iTunes. Пользовательские папки, создаваемые в библиотеке будут заархивированы.|
|Library/Preferences /|Файлы настройки конкретного приложения хранятся в этом каталоге. Не следует создавать эти файлы напрямую. Вместо этого используйте `NSUserDefaults` класса.<br /><br />Содержимое этого каталога резервное копирование по iTunes.|
|Библиотека/кэши /|Каталог кэша находится отлично подходит для хранения файлов данных, которые могут помочь вашему приложению выполнения, но, можно было легко воссоздать. Приложение необходимо создать и удалить эти файлы по мере необходимости и иметь возможность повторного создания этих файлов, при необходимости. iOS 5 также может удалить эти файлы (в ситуациях объема хранилища), однако он не будет выполнено во время работы приложения.<br /><br />Содержимое этого каталога не резервное копирование по iTunes, это означает, что они не будут присутствовать в том случае, если пользователь восстанавливает на устройстве, и они могут не присутствовать после установки обновленной версии приложения.<br /><br />Например в случае, если приложение не удается подключиться к сети, можно использовать каталог кэша для хранения данных или файлов для обеспечения эффективной работы вне сети. Приложения можно сохранить и быстро получать эти данные во время ожидания ответов сети, но его не нужно создавать резервные копии и можно легко восстановить или повторно создать после восстановления или версии обновления.|
|TMP /|Приложения могут хранить временные файлы, которые необходимы только в течение короткого периода в этом каталоге. Чтобы сэкономить место, следует ли удалять файлы, если они больше не требуются. Операционная система может также удалить файлы из этого каталога, когда приложение не выполняется.<br /><br />Содержимое этого каталога не резервное копирование по iTunes.<br /><br />Например каталог tmp может использоваться для хранения временных файлов, загружаются для отображения пользователю (например аватары Twitter или вложений электронной почты), но который может быть удален, когда они будет просмотреть (и загружаться снова, если это требуется в будущем) .|

На этом снимке экрана показана структура каталогов в окне поиска:

[![](file-system-images/08-library-directory.png "На этом снимке экрана показана структура каталогов в окне поиска")](file-system-images/08-library-directory.png#lightbox)

### <a name="accessing-other-directories-programmatically"></a>Программный доступ к другим каталогам

В более ранних каталогов и файлов примерах доступ `Documents` каталога. Для записи в другой каталог, то необходимо создать пути с помощью «..» синтаксис, как показано ниже:

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var library = Path.Combine (documents, "..", "Library");
var filename = Path.Combine (library, "WriteToLibrary.txt");
File.WriteAllText(filename, "Write this text into a file in Library");
```

Создание каталога, аналогичный.

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var library = Path.Combine (documents, "..", "Library");
var directoryname = Path.Combine (library, "NewLibraryDirectory");
Directory.CreateDirectory(directoryname);
```

Пути к `Caches` и `tmp` каталоги могут создаваться следующим образом:

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var cache = Path.Combine (documents, "..", "Library", "Caches");
var tmp = Path.Combine (documents, "..", "tmp");
```

## <a name="sharing-with-the-files-app"></a>Совместное использование с приложением файлы

iOS 11 появилась **файлы** приложения — браузер файлов для iOS, пользователь может просматривать и взаимодействовать с их файлы в iCloud, а также сохраняется любым приложением, которое ее поддерживает. Чтобы разрешить пользователю непосредственный доступ к файлам в вашем приложении, создайте новый логический ключ в **Info.plist** файл `LSSupportsOpeningDocumentsInPlace` и присвойте ему значение `true`, как в данной статье:

![Задайте LSSupportsOpeningDocumentsInPlace в файле Info.plist.](file-system-images/51-supports-opening.png)

Приложения **документов** станут доступны для просмотра в каталоге **файлы** приложения. В **файлы** приложение, перейдите к **на iPhone** и каждого приложения с общими файлами, которые будут видны. Снимки экрана ниже показано, что [файловой системы пример приложения](https://developer.xamarin.com/samples/monotouch/FileSystemSampleCode/) выглядит как:

![Файлы приложения iOS 11](file-system-images/50-files-app-1-sml.png) ![Обзор файлов iPhone](file-system-images/50-files-app-2-sml.png) ![Файлы образца приложения](file-system-images/50-files-app-3-sml.png)

## <a name="sharing-files-with-the-user-through-itunes"></a>Совместное использование файлов с пользователем с помощью iTunes

Пользователям файлов в каталоге документов приложения путем редактирования `Info.plist` и создание **приложения, поддерживающего совместный доступ к iTunes** (`UIFileSharingEnabled`) запись в **источника** Просмотрите, как показано ниже:

[![Добавление приложения поддерживает iTunes, общий доступ к свойству](file-system-images/09-uifilesharingenabled-plist-sml.png)](file-system-images/09-uifilesharingenabled-plist.png#lightbox)

Эти файлы можно получить в iTunes, когда устройство подключено и пользователь нажимает `Apps` вкладки. Например на следующем рисунке показан файлы в общих через iTunes выбранного приложения:

[![На этом снимке экрана показаны файлы в выбранное приложение, совместно с помощью iTunes](file-system-images/10-itunes-file-sharing-sml.png)](file-system-images/10-itunes-file-sharing.png#lightbox)

Пользователям доступны только элементы верхнего уровня в этом каталоге через iTunes. Они не могут видеть содержимое всех подкаталогах (хотя их можно скопировать их на свой компьютер или удалить их). Например с GoodReader, файлы PDF и EPUB может использоваться вместе с приложением, чтобы пользователи могут читать их на устройствах iOS.

Пользователям, которые изменяют содержимое своих папок документов может вызвать проблемы, если не соблюдать осторожность. Приложения должны учитывать это и быть устойчивым к разрушающее обновления папки «документы».

В примере кода, в этой статье создается файл и папку в папке документы (в **SampleCode.cs**) и обеспечивает совместное использование файлов в **Info.plist** файла. На этом снимке экрана показано, как они отображаются в iTunes:

[![На этом снимке экрана показано, как отображаются файлы в iTunes](file-system-images/15-itunes-file-sharing-example-sml.png)](file-system-images/15-itunes-file-sharing-example.png#lightbox)

Ссылаться на [работа с образами](~/ios/app-fundamentals/images-icons/index.md) статье сведения о настройке значков для приложения и для любых типов настраиваемого документа создается.

Если `UIFileSharingEnabled` ключ имеет значение false или не существует, а затем общий доступ к файлам является, по умолчанию отключена, и пользователи не смогут взаимодействовать с вашим каталогом документов.

## <a name="backup-and-restore"></a>резервное копирование и восстановление;

Устройство архивируется iTunes, все, что каталоги, созданные в домашнем каталоге вашего приложения будет сохранен за исключением следующих каталогов:

- **[ApplicationName] .app** — не запись в этот каталог, так как она была подписана и поэтому должны оставаться неизменными после установки. Он может содержать ресурсы, доступ из кода, но они не требуют резервного копирования, так как они будет восстановлен, скачав приложение повторно.
- **Библиотека/кэши** — каталог кэша предназначен для рабочих файлов, которые не нужно создавать резервные копии.
- **TMP** — этот каталог используется для временных файлов, которые создаются и удаляются, когда не нужно, или для файлов удаляет, iOS, когда ему пространства.

Резервное копирование большой объем данных может занять много времени. Если вы решите, необходимо создать резервную копию любого конкретного документа или данных, в приложении следует использовать либо использовать документы и библиотеки. Для хранения временных данных или файлы, которые можно легко извлечь из сети используйте кэши или каталог tmp.

> [!NOTE]
> iOS будет «clean» файловой системы. Если устройство критически хватает места на диске.
> Этот процесс будут удалены все файлы из библиотеки/кэши и tmp папку приложений, которые в данный момент не выполняются.

## <a name="complying-with-ios-5-icloud-backup-restrictions"></a>Соблюдение ограничений резервного копирования 5 iCloud iOS

> [!NOTE]
> Несмотря на то, что эта политика была впервые появилась в iOS 5 (который может показаться очень давно) руководство находится по-прежнему важны для приложения уже сегодня.

Компания Apple представила *резервной копии в iCloud* функциональных возможностей с помощью iOS 5. Если включено iCloud резервного копирования, все файлы в домашний каталог приложения (за исключением каталогов, которые не архивируются обычным образом, например, набор приложений, `Caches`, и `tmp`) сохраненный в резервной копии iCloud серверам. Эта функция предоставляет пользователю полного резервного копирования, в случае потери, кражи или повреждения устройства.

Так, как iCloud предоставляет только 5 ГБ пространства на «free» для каждого пользователя и избегать без необходимости использования пропускной способности, Apple ожидает, что приложения, чтобы только резервного копирования важные данные пользователей. В соответствии с iOS рекомендации по хранилища данных, следует ограничить объем данных, резервного копирования, выполняет следующие элементы:

- Сохранять только пользовательские данные или данные, которые в противном случае не может быть создан повторно в каталоге документы (который является резервных копий).
- Все остальные данные, можно легко повторно создать или повторно загрузить в Store `Library/Caches` или `tmp` (который не является резервных копий и может быть «Очистить»).
- Если у вас есть файлы, которые могут подходить для `Library/Caches` или `tmp` папке, но вы не хотите для «очистки», хранить их в другом месте (например `Library/YourData`) и применить "не вверх" атрибут, чтобы заблокировать развертывание файлов использования резервной копии в iCloud пропускная способность и место на диске. Эти данные все равно используется пространство на устройстве, поэтому следует тщательно управлять им и удалите его, если это возможно.

"Не создавать резервные копии" атрибут задается с помощью `NSFileManager` класса. Обеспечивает класс `using Foundation` и вызвать `SetSkipBackupAttribute` следующим образом:

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var filename = Path.Combine (documents, "LocalOnly.txt");
File.WriteAllText(filename, "This file will never get backed-up. It would need to be re-created after a restore or re-install");
NSFileManager.SetSkipBackupAttribute (filename, true); // backup will be skipped for this file
```

Когда `SetSkipBackupAttribute` — `true` файл не будет резервные копии, независимо от того, он хранится в каталоге (даже `Documents` directory). Можно запросить атрибута с помощью `GetSkipBackupAttribute` метод и можно сбросить путем вызова `SetSkipBackupAttribute` метод с `false`, следующим образом:

```csharp
NSFileManager.SetSkipBackupAttribute (filename, false); // file will be backed-up
```

## <a name="sharing-data-between-ios-apps-and-app-extensions"></a>Обмен данными между приложениями iOS и расширения приложений

Расширения приложений выполняется как часть ведущего приложения (в отличие от содержащего приложения), общий доступ к данным не выполняется автоматически включены, поэтому не требуется дополнительной работы. Группы приложений — это механизм iOS использует, чтобы разрешить различные приложения для обмена данными. Если приложения были правильно настроены с правильные права доступа и подготовки, получения доступа к общей папке за пределами их обычного iOS "песочницы".

### <a name="configure-an-app-group"></a>Настройка группы приложений

Общее расположение настраивается с помощью [групп приложений](https://developer.apple.com/library/archive/documentation/Miscellaneous/Reference/EntitlementKeyReference/Chapters/EnablingAppSandbox.html#//apple_ref/doc/uid/TP40011195-CH4-SW19), настроенный в **сертификаты, идентификаторы и профили** разделе [Центр разработчиков iOS](https://developer.apple.com/devcenter/ios/). Это значение также должно быть указано в каждом проекте **Entitlements.plist**.

Сведения о создании и настройке группы приложений, см. [возможностей групп приложений](~/ios/deploy-test/provisioning/capabilities/app-groups-capabilities.md) руководства.

### <a name="files"></a>Файлы

Приложения iOS и расширения могут также совместно использовать файлы, используя общий путь к файлу (учитывая их должным образом настроены правильные права доступа и подготовки):

```csharp
var FileManager = new NSFileManager ();
var appGroupContainer =FileManager.GetContainerUrl ("group.com.xamarin.WatchSettings");
var appGroupContainerPath = appGroupContainer.Path

Console.WriteLine ("Group Path: " + appGroupContainerPath);

// use the path to create and update files
...
```

> [!IMPORTANT]
> Если возвращается пути группы `null`, проверьте конфигурацию назначениях и профиль подготовки и убедитесь, что они верны.

## <a name="application-version-updates"></a>Обновления версии приложения

После загрузки новой версии приложения iOS создает домашний каталог и сохраняет новый пакет приложений в нем. iOS затем перемещает следующие папки из предыдущей версии вашего пакета приложения в новый корневой каталог:

- **Документы**
- **Библиотека**

Другие каталоги могут также копирование и поместить в новый домашнем каталоге, но они гарантированы не копируются, поэтому приложение не следует полагаться на поведение этой системы.

## <a name="summary"></a>Сводка

В этой статье объясняется, что операции файловой системы с помощью Xamarin.iOS похожи на любом другом приложении .NET. Также появился "песочницы" приложения и просмотреть последствия для безопасности, которые она вызывает. Далее его изучения концепцию пакета приложения. Наконец перечислены специальные каталоги, доступные для приложения и описано их роли во время обновления приложения и резервные копии.

## <a name="related-links"></a>Связанные ссылки

- [Пример кода файловой системы](https://developer.xamarin.com/samples/FileSystemSampleCode/)
- [Руководство по программированию в системе файл](http://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/FileSystemProgrammingGUide/Introduction/Introduction.html)
- [Регистрация файла типы поддерживает ваше приложение](http://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/DocumentInteraction_TopicsForIOS/Articles/RegisteringtheFileTypesYourAppSupports.html#/apple_ref/doc/uid/TP40010411-SW1)
