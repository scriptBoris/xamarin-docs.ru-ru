---
title: Жизненный цикл действия
description: Действия являются основной строительный блок рабочих приложений Android, и они могут присутствовать в нескольких различных состояний. Жизненный цикл действия начинается с создания экземпляра и заканчивается уничтожение и включает много состояний между ними. При изменении состояния действия соответствующие жизненного цикла события вызове метода уведомления активности внесение изменений состояния и позволяя ему для выполнения кода, чтобы адаптироваться к это изменение. В этой статье рассматриваются жизненного цикла действий и объясняется ответственность за наличие действия выполнения каждой из этих изменений как часть долгосрочных, надежные приложения.
ms.prod: xamarin
ms.assetid: 05B34788-F2D2-4347-B66B-40AFD7B1D167
ms.technology: xamarin-android
author: conceptdev
ms.author: crdun
ms.date: 02/28/2018
ms.openlocfilehash: 3592a3027469cb9997d973db53d636ddea9e679d
ms.sourcegitcommit: e268fd44422d0bbc7c944a678e2cc633a0493122
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "50110892"
---
# <a name="activity-lifecycle"></a>Жизненный цикл действия

_Действия являются основной строительный блок рабочих приложений Android, и они могут присутствовать в нескольких различных состояний. Жизненный цикл действия начинается с создания экземпляра и заканчивается уничтожение и включает много состояний между ними. При изменении состояния действия соответствующие жизненного цикла события вызове метода уведомления активности внесение изменений состояния и позволяя ему для выполнения кода, чтобы адаптироваться к это изменение. В этой статье рассматриваются жизненного цикла действий и объясняется ответственность за наличие действия выполнения каждой из этих изменений как часть долгосрочных, надежные приложения._

## <a name="activity-lifecycle-overview"></a>Обзор жизненного цикла действия

Действия являются необычные понятие программирования для Android. В процесс разработки традиционных приложений обычно имеется статический метод main, который выполняется для запуска приложения. С Android Однако все по-другому; Приложения Android можно запустить с помощью любого зарегистрированного действия в приложении. На практике большинство приложений имеют только определенное действие, заданным как точку входа приложения. Тем не менее, если приложение аварийно завершает работу, или прерывается, операционной системы, ОС может попытаться перезапустить приложения на последнее действие open или в любом месте стеке предыдущего действия.
Кроме того ОС может приостановки действий в том случае, если они не active и их восстановления, если он не хватает памяти. Чтобы разрешить приложению правильно восстановить свое состояние в случае, если действие перезапуска, особенно в том случае, если, действие зависит от данных из предыдущих действий должны выполняться тщательного анализа.

Жизненный цикл действия реализуется как коллекция вызовов методов операционной системы на протяжении жизненного цикла действия. Эти методы позволяют разработчикам реализовать функциональные возможности, необходимые для удовлетворения требований управления состояния и ресурсов приложений.

Очень важно для разработчиков приложений для анализа требования каждого действия, чтобы определить, какие методы, предоставляемые жизненный цикл действия должны быть реализованы. Если этого не сделать может привести к нестабильной работе приложения, сбои, Раздувание ресурсов и нестабильности даже базовой операционной системы.

В этой главе рассматриваются жизненный цикл действия подробно, включая:

-  Состояния действия
-  Методы жизненного цикла
-  Сохранение состояния приложения


Этот раздел также содержит [Пошаговое руководство](~/android/app-fundamentals/activity-lifecycle/saving-state.md) о том, как для эффективного сохранения состояния во время жизненный цикл действия, которые предоставляют практические примеры. В конце данной главы необходимо понимание жизненный цикл действия и как его поддерживать в приложении Android.

## <a name="activity-lifecycle"></a>Жизненный цикл действия

Жизненный цикл действия Android состоит из набора методов, предоставляемых в рамках класса действия, которые предоставляют разработчику архитектура управления ресурсами. Эта платформа позволяет разработчикам требованиям управления уникальное состояние каждого действия в приложении и правильно обрабатывать управления ресурсами.

### <a name="activity-states"></a>Состояния действия

ОС Android выполняет оценку действий в зависимости от их состояния. Это помогает выявить действия, которые больше не используются, позволяя операционной системы для освобождения памяти и ресурсов Android. На следующей схеме состояний, которые можно выполнить действие во время существования:

[![Схема состояния активности](images/image1-sml.png)](images/image1.png#lightbox)

Эти состояния можно разбить на 4 группы следующим образом:

1.  *Активные или запущенные* &ndash; рассматриваемые активный или выполнения, если они находятся на переднем плане, называемые также верхней части стека действие действия. Это считается наибольшей активности приоритет в Android и таким образом будет только завершить операционной системы в чрезвычайных ситуациях, таких как, если действие пытается использовать больше памяти, чем доступно на устройстве, так как это может вызвать зависание пользовательского интерфейса.

1.  *Приостановлено* &ndash; когда устройство переходит в спящий режим или действия по-прежнему отображаются, но частично скрыт на основе новых, отличных от полноразмерные или прозрачное действие, действие считается приостановлена. Приостановленное действия находятся все еще существует, то есть они обеспечивают всю информацию о состоянии и член и будет прикреплен к, чтобы диспетчер окон. Это рассматривается как второй наивысший приоритет действия в Android и, таким образом, будут прерваны в ОС, только если завершение этого действия будет удовлетворять требования к ресурсам, нужно четко активный/запущенное действие стабильной и отвечает на запросы.

1.  *Остановить/Backgrounded* &ndash; действий, которые полностью скрыт другим действием, считаются остановлен или в фоновом режиме.
    Остановлена действий по-прежнему пытаться сохранить их состояние и сведения о члене для, пока считается, что возможно, но остановленное действий являются самым низким приоритетом из трех состояний, и, таким образом, операционная система будет kill действий в этом состоянии, во-первых, для удовлетворения ресурса требования к более высоким приоритетом действий.

1.  *Перезапустить* &ndash; это возможно, для действия, который лежит в интервале от приостановлена до остановки в жизненном цикле, удаляются из памяти системой Android. Если пользователь переходит обратно к операции, к которой он должен быть перезапущен, восстановить его ранее сохраненное состояние, а затем отображаются для пользователя.


### <a name="activity-re-creation-in-response-to-configuration-changes"></a>Повторное создание действия в ответ на изменения конфигурации

Чтобы сделать сложнее: вопросы и ответы, Android создает один дополнительные гаечного ключа в наборе, вызывается изменения конфигурации. Изменения конфигурации выполняется быстрое действие удаления или повторно-creation циклов, возникающих при изменении конфигурации действия, например, если устройство [повернутый](~/android/app-fundamentals/handling-rotation.md) (и действие должно быть повторно создан в альбомной или книжной ориентации режим), при отображении клавиатуры (и действия предоставляется возможность изменять размер), или при помещении устройства в закрепления, среди прочего.

Изменения конфигурации по-прежнему вызывать те же изменения состояния действия, которые произошли бы во время остановки и перезапуска действие. Тем не менее чтобы убедиться в том, что приложение, в том числе быстрые и выполняет также во время изменения конфигурации, очень важно, они обрабатываться как можно быстрее. По этой причине Android имеет определенный интерфейс API, который может использоваться для сохранения состояния во время изменения конфигурации.
Мы рассмотрим это позднее в [управление состоянии на протяжении всего жизненного цикла](~/android/app-fundamentals/activity-lifecycle/index.md#Managing_State_Throughout_the_Lifecycle) раздел.

### <a name="activity-lifecycle-methods"></a>Методы жизненного цикла действия

Пакет SDK для Android и по расширению, Xamarin.Android framework предоставляют мощную модель для управления состоянием действий в приложении. При изменении состояния действия, действие получает уведомление в ОС, который вызывает конкретные методы для этого действия. На следующей схеме показана этих методов по отношению к их жизненный цикл:

[![Блок-схема жизненного цикла действия](images/image2-sml.png)](images/image2.png#lightbox)

Как разработчик может обрабатывать изменения состояния, переопределив эти методы в рамках действия. Важно отметить, что все методы жизненного цикла вызываются в потоке пользовательского интерфейса и заблокирует ОС от выполнения создается следующая часть работы пользовательского интерфейса, например, для скрытия текущим действием, отображение нового действия и т. д. Таким образом код в этих методах должен быть достаточно кратким вы хорошо работает приложение. Любой длительно выполняемых задач должна выполняться в фоновом потоке.

Давайте рассмотрим каждое из этих методов жизненного цикла и их использования:

#### <a name="oncreate"></a>OnCreate

[OnCreate](https://developer.xamarin.com/api/member/Android.App.Activity.OnCreate/p/Android.OS.Bundle/) — это первый метод, вызываемый при создании действия.
`OnCreate` всегда переопределяется для инициализаций запуска, которые могут быть действием такие как:

-  Создание представлений
-  Инициализация переменных
-  Привязка к спискам статических данных


`OnCreate` принимает [пакета](https://developer.xamarin.com/api/type/Android.OS.Bundle/) параметр, который представляет собой словарь для хранения и передачи сведений о состоянии и объектов между действиями, если пакет не равно null, это указывает, перезапускается действия и его следует восстановить свое состояние из предыдущий экземпляр. Следующий код иллюстрирует способ извлечения значений из пакета:

```csharp
protected override void OnCreate(Bundle bundle)
{
   base.OnCreate(bundle);

   string intentString;
   bool intentBool;

   if (bundle != null)
   {
      intentString = bundle.GetString("myString");
      intentBool = bundle.GetBoolean("myBool");
   }

   // Set our view from the "main" layout resource
   SetContentView(Resource.Layout.Main);
}
```

Один раз `OnCreate` имеет завершена, будет вызывать Android `OnStart`.

#### <a name="onstart"></a>OnStart

[OnStart](https://developer.xamarin.com/api/member/Android.App.Activity.OnStart/) всегда вызывается системой после `OnCreate` завершения работы. Действия могут переопределить этот метод, если им необходим для выполнения какого-либо права конкретные задачи, прежде чем действие становится видимым, такие как обновление текущие значения представлений в пределах действия. Android будет вызывать `OnResume` сразу же после этого метода.

#### <a name="onresume"></a>OnResume

Системные вызовы [OnResume](https://developer.xamarin.com/api/member/Android.App.Activity.OnResume/) когда действия будет готов начать взаимодействие с пользователем.
Действия должны переопределять этот метод для выполнения задач, таких как:

-  Медленное повышение частоты кадров (обычная задача в стандартных игр)
-  Запуск анимации
-  Ожидание обновления GPS
-  Отображаются соответствующие оповещения и диалоговые окна
-  Связывать обработчики внешних событий


Например в следующем фрагменте кода показано, как инициализировать камеры:

```csharp
public void OnResume()
{
    base.OnResume(); // Always call the superclass first.

    if (_camera==null)
    {
        // Do camera initializations here
    }
}
```

`OnResume` тем, что любая операция, в `OnPause` должно быть не делать `OnResume`, так как это единственный метод жизненного цикла, которое гарантированно будет выполняться `OnPause` при переводе действие обратно в жизнь.

#### <a name="onpause"></a>OnPause

[OnPause](https://developer.xamarin.com/api/member/Android.App.Activity.OnPause/) вызывается, когда система пытается поместить действие в фоновом режиме или в случаях, когда действие становится частично закрыт. Действия должны переопределить этот метод, если им необходимо:

-   Зафиксировать несохраненные изменения в постоянных данных

-   Уничтожения или очистка других объектов потребления ресурсов

-   Собственный частоты кадров и приостановка анимации

-   Отменить регистрацию обработчиков внешнего события или обработчики для уведомляющих (т. е. те, которые привязаны к службе). Это необходимо сделать для предотвращения утечек памяти действия.

-   Аналогично, если действие отображается, никакие диалоговые окна или оповещения, они должны удаляться с `.Dismiss()` метод.

Например, следующий фрагмент кода будет освобождать камеры, как действие не может вносить использовать его во время паузы:

```csharp
public void OnPause()
{
    base.OnPause(); // Always call the superclass first

    // Release the camera as other activities might need it
    if (_camera != null)
    {
        _camera.Release();
        _camera = null;
    }
}
```

Существует два возможных жизненный цикл метода, которые будут вызываться после `OnPause`:

1.  `OnResume` будет вызываться, если действие должно возвращаться на передний план.
1.  `OnStop` будет вызываться, если действие помещается в фоновом режиме.


#### <a name="onstop"></a>OnStop

[OnStop](https://developer.xamarin.com/api/member/Android.App.Activity.OnStop/) вызывается, когда действие больше не отображается для пользователя. Это происходит, когда происходит одно из следующих:

-  Новое действие запускается и закрывающий это действие.
-  Существующее действие переводится на передний план.
-  Действие уничтожается.


`OnStop` не всегда можно вызывать в ситуациях нехватки памяти, например, если нехватка ресурсов Android и не может правильно фоновое действие. По этой причине лучше не полагаться на `OnStop` получение называется при подготовке действие для удаления. Далее методы жизненного цикла, которые могут быть вызваны после этого будет `OnDestroy` Если действие выходит из употребления, или `OnRestart` Если действия возвращается для взаимодействия с пользователем.

#### <a name="ondestroy"></a>onDestroy

[OnDestroy](https://developer.xamarin.com/api/member/Android.App.Activity.OnDestroy/) — последний метод, который вызывается для экземпляра действия, прежде чем он уничтожен и полностью удаляется из памяти. В чрезвычайных ситуациях Android может завершить процесс приложения, на котором размещается действие, которое приведет к `OnDestroy` не вызывается. Большинство действий не будет реализовывать этот метод, так как большинство очистки и завершение работы было сделано `OnPause` и `OnStop` методы. `OnDestroy` Метод обычно переопределяется для очистки долго выполняющего ресурсы могут допускать утечку ресурсов. Примером этого может быть фоновым потокам, которые были запущены в `OnCreate`.

Будет существовать методы жизненного цикла, не вызывается после уничтожения действия.

#### <a name="onrestart"></a>OnRestart

[OnRestart](https://developer.xamarin.com/api/member/Android.App.Activity.OnRestart/) вызывается после того, действие было остановлено, то перед его повторном запуске. Хорошим примером этого бы в том случае, когда пользователь нажимает кнопки домашней страницы в действие в приложении. В этом случае `OnPause` и затем `OnStop` методы вызываются, и действия, перемещаются в фоновом режиме, но не уничтожается. Если бы пользователь, а затем для восстановления приложения с помощью диспетчера задач или аналогичного приложения, вызовет Android `OnRestart` метод действия.

Существует общих принципов какого рода логики должны быть реализованы в `OnRestart`. Это обусловлено `OnStart` всегда вызывается независимо от того, создается ли действие или перезапустить, чтобы все ресурсы, необходимые действия, которые должны быть инициализированы в `OnStart`, а не `OnRestart`.

Далее метод жизненного цикла, вызванный после `OnRestart` будет `OnStart`.

### <a name="back-vs-home"></a>Обратно vs. Главная страница

На многих устройствах Android имеется две отдельных кнопки: кнопка «Назад» и кнопка «Главная». Пример этого можно увидеть на следующем снимке экрана из Android 4.0.3:

[![Кнопки домашней назад и](images/image4-sml.png)](images/image4.png#lightbox)

Есть небольшая разница между двумя кнопками, несмотря на то, что у них могут иметь один и тот же эффект размещения приложения в фоновом режиме. Когда пользователь щелкает кнопку "Назад", они говорят Android, что они выполняются с действием. Android будет уничтожена действия. Напротив, при нажатии кнопки домашней страницы действие просто помещается в фоновом режиме &ndash; Android не прервет действие.

<a name="Managing_State_Throughout_the_Lifecycle" />

## <a name="managing-state-throughout-the-lifecycle"></a>Управление состоянием на протяжении жизненного цикла

При действие остановлена или уничтожения система предоставляет возможность сохранения состояния действия для более поздней версии расконсервации.
Это сохраненное состояние называется состояние экземпляра. Android предоставляет три способа хранения состояния экземпляра во время их жизненный цикл:

1. Хранение значений-примитивов в `Dictionary` называется [пакета](https://developer.xamarin.com/api/type/Android.OS.Bundle/) что Android будет использовать для сохранения состояния.

1. Создание пользовательского класса, который будет содержать сложные значения, такие как растровые изображения. Android будет использовать этот пользовательский класс для сохранения состояния.

1. Обход управления жизненным циклом конфигураций изменений и при условии, что полный ответственность за поддержание состояния в действии.


В этом руководстве описывается первые два варианта.



### <a name="bundle-state"></a>Состояние пакета

Основной параметр для сохранения состояния экземпляра, — использовать объект словарь ключей и значений, известный как [пакета](https://developer.xamarin.com/api/type/Android.OS.Bundle/).
Помните, что при создании действия, `OnCreate` метод передается пакет в качестве параметра, этот пакет можно использовать для восстановления состояния экземпляра. Не рекомендуется использовать пакет для более сложных данных, которые не быстро и легко сериализовать в пары (например, растровые изображения); "ключ значение" Вместо этого он должен использоваться для простых значений, таких как строки.

Действие предоставляет методы для сохранения и извлечения состояния экземпляра в пакете:

-   [OnSaveInstanceState](https://developer.xamarin.com/api/member/Android.App.Activity.OnSaveInstanceState/p/Android.OS.Bundle/) &ndash; вызывается с Android при уничтожении действия. Действия можно реализовать этот метод, если им необходимо сохранять все элементы состояния ключ/значение.

-   [OnRestoreInstanceState](https://developer.xamarin.com/api/member/Android.App.Activity.OnRestoreInstanceState/p/Android.OS.Bundle/) &ndash; это называется после `OnCreate` метод завершения и предоставляет еще одна возможность для действия восстановить свое состояние после завершения установки.

На следующей схеме показана, как используются эти методы:

[![Блок-схема состояния пакета](images/image3-sml.png)](images/image3.png#lightbox)

#### <a name="onsaveinstancestate"></a>OnSaveInstanceState

[OnSaveInstanceState](https://developer.xamarin.com/api/member/Android.App.Activity.OnSaveInstanceState/p/Android.OS.Bundle/) будет вызываться, как выполняется остановка действия. Он будет получать действия можно хранить в состояние параметра пакета. При изменении конфигурации устройства, можно использовать действие `Bundle` объект, переданный для сохранения состояния действия путем переопределения `OnSaveInstanceState`. Рассмотрим следующий пример кода:

```csharp
int c;

protected override void OnCreate (Bundle bundle)
{
  base.OnCreate (bundle);

  this.SetContentView (Resource.Layout.SimpleStateView);

  var output = this.FindViewById<TextView> (Resource.Id.outputText);

  if (bundle != null) {
    c = bundle.GetInt ("counter", -1);
  } else {
    c = -1;
  }

  output.Text = c.ToString ();

  var incrementCounter = this.FindViewById<Button> (Resource.Id.incrementCounter);

  incrementCounter.Click += (s,e) => {
    output.Text = (++c).ToString();
  };
}
```

В приведенном выше коде увеличивает целочисленное именованное `c` при кнопки с именем `incrementCounter` нажатии вывод результата в `TextView` с именем `output`. Когда происходит изменение конфигурации — например, при повороте устройства — приведенный выше код будет утеряна значение `c` поскольку `bundle` бы `null`, как показано на рисунке ниже:

[![Не отображаются предыдущее значение](images/07-sml.png)](images/07.png#lightbox)

Чтобы сохранить значение `c` в этом примере можно переопределить действия `OnSaveInstanceState`, сохраняя значения в наборе, как показано ниже:

```csharp
protected override void OnSaveInstanceState (Bundle outState)
{
  outState.PutInt ("counter", c);
  base.OnSaveInstanceState (outState);
}
```

Теперь при повороте устройства для принятия новой ориентации, целочисленное значение сохраняется в пакете и извлекается с помощью строки:

```csharp
c = bundle.GetInt ("counter", -1);
```

> [!NOTE]
> Это важно всегда вызов базовой реализации `OnSaveInstanceState` таким образом, чтобы состояние иерархии представления также могут сохраняться.



##### <a name="view-state"></a>Состояние представления

Переопределение `OnSaveInstanceState` представляет собой соответствующий механизм для сохранения временных данных в действие через изменения ориентации, например счетчика в приведенном выше примере. Однако реализация по умолчанию `OnSaveInstanceState` позаботится о сохранении временных данных в пользовательском Интерфейсе для каждого представления до тех пор, пока каждое представление имеет идентификатор, назначенный. Предположим, например, приложение имеет `EditText` элемент, определенный в формате XML следующим образом:

```xml
<EditText android:id="@+id/myText"
  android:layout_width="fill_parent"
  android:layout_height="wrap_content"/>
```

Так как `EditText` элемент управления имеет `id` назначено, когда пользователь вводит некоторые данные и повороте устройства, данные по-прежнему отображаются, как показано ниже:

[![Данные сохраняются в альбомной ориентации](images/08-sml.png)](images/08.png#lightbox)

#### <a name="onrestoreinstancestate"></a>OnRestoreInstanceState

[OnRestoreInstanceState](https://developer.xamarin.com/api/member/Android.App.Activity.OnRestoreInstanceState/p/Android.OS.Bundle/) будет вызываться после `OnStart`. Он предоставляет возможность восстанавливать состояния, который был ранее сохранен пакет во время предыдущего действия `OnSaveInstanceState`. Это связано с тем же пакета, который предоставляется `OnCreate`, но при этом.

В следующем коде показано, как можно восстановить состояние `OnRestoreInstanceState`:

```csharp
protected override void OnRestoreInstanceState(Bundle savedState)
{
    base.OnRestoreSaveInstanceState(savedState);
    var myString = savedState.GetString("myString");
    var myBool = savedState.GetBoolean("myBool");
}
```

Этот метод используется для обеспечения дополнительных возможностей вокруг в том случае, когда состояние должно быть восстановлено. Иногда бывает более подходящим решением может подождать, пока все операции инициализации выполняются перед восстановлением состояния экземпляра. Кроме того подкласс существующее действие может требоваться только восстановить определенные значения из состояния экземпляра. Во многих случаях это не требуется переопределять `OnRestoreInstanceState`, так как большинство действий можно восстановить состояние, с помощью пакета для `OnCreate`.

Пример сохранения состояния с помощью `Bundle`, см. [Пошаговое руководство. Сохранение действие состояния](saving-state.md).


#### <a name="bundle-limitations"></a>Ограничения пакета

Несмотря на то что `OnSaveInstanceState` позволяет легко для сохранения временных данных, он имеет некоторые ограничения:

-   Он не вызывается во всех случаях. Например, нажатие клавиши **Главная** или **обратно** для выхода из действие не приведет к `OnSaveInstanceState` вызова.

-   Переданный пакет `OnSaveInstanceState` не предназначена для больших объектов, таких как изображения. В случае больших объектов, сохранение объекта из [OnRetainNonConfigurationInstance](https://developer.xamarin.com/api/member/Android.App.Activity.OnRetainNonConfigurationInstance/) предпочтительнее, как описано ниже.

-   Данные, сохраненные с помощью пакета сериализуется, что может привести к задержкам.

Состояние пакета полезно для простых данных, который не использует много памяти, тогда как *данные экземпляра не конфигурации* полезна для более сложных данных, или данные, ресурсоемкость извлечения, например, вызов веб-службы или очень сложный запрос к базе данных. Данные экземпляра конфигурации не сохраняются в объекте, при необходимости. В следующем разделе описывается `OnRetainNonConfigurationInstance` как способ сохранения более сложными типами данных посредством изменения конфигурации.


### <a name="persisting-complex-data"></a>Сохранение сложных данных.

Помимо сохранения данных в пакете Android также поддерживает сохранение данных путем переопределения [OnRetainNonConfigurationInstance](https://developer.xamarin.com/api/member/Android.App.Activity.OnRetainNonConfigurationInstance/) и возвращение экземпляра `Java.Lang.Object` , содержащий данные для сохранения. Существует два основных преимущества использования `OnRetainNonConfigurationInstance` для сохранения состояния:

-   Объект, возвращенный из `OnRetainNonConfigurationInstance` выполняет также с типами данных более крупных и сложных, так как в памяти сохраняет этот объект.

-   `OnRetainNonConfigurationInstance` Метод, вызываемый по запросу и только в том случае, при необходимости. Это наиболее экономичным решением, чем при использовании кэша вручную.

С помощью `OnRetainNonConfigurationInstance` подходит для сценариев, где ресурсоемкость извлечения данных несколько раз, например вызовы веб-службы. Например рассмотрим следующий код, который выполняет поиск Twitter:

```csharp
public class NonConfigInstanceActivity : ListActivity
{
  protected override void OnCreate (Bundle bundle)
  {
    base.OnCreate (bundle);
    SearchTwitter ("xamarin");
  }

  public void SearchTwitter (string text)
  {
    string searchUrl = String.Format("http://search.twitter.com/search.json?" + "q={0}&rpp=10&include_entities=false&" + "result_type=mixed", text);

    var httpReq = (HttpWebRequest)HttpWebRequest.Create (new Uri (searchUrl));
    httpReq.BeginGetResponse (new AsyncCallback (ResponseCallback), httpReq);
  }

  void ResponseCallback (IAsyncResult ar)
  {
    var httpReq = (HttpWebRequest)ar.AsyncState;

    using (var httpRes = (HttpWebResponse)httpReq.EndGetResponse (ar)) {
      ParseResults (httpRes);
    }
  }

  void ParseResults (HttpWebResponse httpRes)
  {
    var s = httpRes.GetResponseStream ();
    var j = (JsonObject)JsonObject.Load (s);

    var results = (from result in (JsonArray)j ["results"] let jResult = result as JsonObject select jResult ["text"].ToString ()).ToArray ();

    RunOnUiThread (() => {
      PopulateTweetList (results);
    });
  }

  void PopulateTweetList (string[] results)
  {
    ListAdapter = new ArrayAdapter<string> (this, Resource.Layout.ItemView, results);
  }
}
```

Этот код извлекает результаты из Интернета, в формате JSON, анализирует их и затем возвращает результаты в список, как показано на следующем снимке экрана:

[![Результаты отображаются на экране](images/06-sml.png)](images/06.png#lightbox)

При возникновении изменений в конфигурации — например, при повороте устройства - код повторяет этот процесс. Для повторного использования изначально полученные результаты и не вызывают ошибочные, избыточных сетевых вызовов, можно использовать `OnRetainNonconfigurationInstance` для сохранения результатов, как показано ниже:

```csharp
public class NonConfigInstanceActivity : ListActivity
{
  TweetListWrapper _savedInstance;

  protected override void OnCreate (Bundle bundle)
  {
    base.OnCreate (bundle);

    var tweetsWrapper = LastNonConfigurationInstance as TweetListWrapper;

    if (tweetsWrapper != null) {
      PopulateTweetList (tweetsWrapper.Tweets);
    } else {
      SearchTwitter ("xamarin");
    }

    public override Java.Lang.Object OnRetainNonConfigurationInstance ()
    {
      base.OnRetainNonConfigurationInstance ();
      return _savedInstance;
    }

    ...

    void PopulateTweetList (string[] results)
    {
      ListAdapter = new ArrayAdapter<string> (this, Resource.Layout.ItemView, results);
      _savedInstance = new TweetListWrapper{Tweets=results};
    }
}
```

Теперь при повороте устройства исходные результаты извлекаются из `LastNonConfiguartionInstance` свойство. В этом примере результаты состоят из `string[]` содержащий твитов. Так как `OnRetainNonConfigurationInstance` требует `Java.Lang.Object` возвращаться, `string[]` упаковывается в классе, который наследуется от класса `Java.Lang.Object`, как показано ниже:

```csharp
class TweetListWrapper : Java.Lang.Object
{
  public string[] Tweets { get; set; }
}
```

Например, при попытке использовать `TextView` как объект, возвращенный из `OnRetainNonConfigurationInstance` приводят к утечке действия, как показано в следующем коде:

```csharp
TextView _textView;

protected override void OnCreate (Bundle bundle)
{
  base.OnCreate (bundle);

  var tv = LastNonConfigurationInstance as TextViewWrapper;

  if(tv != null) {
    _textView = tv;
    var parent = _textView.Parent as FrameLayout;
    parent.RemoveView(_textView);
  } else {
    _textView = new TextView (this);
    _textView.Text = "This will leak.";
  }

  SetContentView (_textView);
}

public override Java.Lang.Object OnRetainNonConfigurationInstance ()
{
  base.OnRetainNonConfigurationInstance ();
  return _textView;
}
```

В этом разделе мы показали, как для сохранения данных простого конечного с `Bundle`, и сохранять более сложные типы данных с помощью `OnRetainNonConfigurationInstance`.

## <a name="summary"></a>Сводка

Жизненный цикл действия Android предоставляет мощную платформу для управления состоянием действий в приложении, но это может быть сложным для понимания и реализации. В этой главе представлены различные состояния, которые действие может выполнить во время существования, а также методы жизненного цикла, связанные с ними. Далее рекомендации указано о том, какого рода логики должно выполняться в каждом из этих методов.


## <a name="related-links"></a>Связанные ссылки

- [Обработка поворота](~/android/app-fundamentals/handling-rotation.md)
- [Действие Android](https://developer.xamarin.com/api/type/Android.App.Activity/)
