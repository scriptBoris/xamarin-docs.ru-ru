---
title: Службы работает Android в удаленных процессов
description: Как правило все компоненты в приложении Android будут работать в одном процессе. Службы Android являются исключением к этому, их можно настроить для работы в собственных процессов и совместно с другими приложениями, в том числе от других разработчиков Android. В этом руководстве описывается, как создать и использовать Android удаленной службы, с помощью Xamarin.
ms.prod: xamarin
ms.assetid: 27A2E972-A690-480B-B31D-5EF1F74F673C
ms.technology: xamarin-android
author: conceptdev
ms.author: crdun
ms.date: 02/16/2018
ms.openlocfilehash: db312c4c102feb98791109af19185762bb25856e
ms.sourcegitcommit: 849bf6d1c67df943482ebf3c80c456a48eda1e21
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/12/2018
ms.locfileid: "51528849"
---
# <a name="running-android-services-in-remote-processes"></a>Службы работает Android в удаленных процессов

_Как правило все компоненты в приложении Android будут работать в одном процессе. Службы Android являются исключением к этому, их можно настроить для работы в собственных процессов и совместно с другими приложениями, в том числе от других разработчиков Android. В этом руководстве описывается, как создать и использовать Android удаленной службы, с помощью Xamarin._

## <a name="out-of-process-services-overview"></a>Внепроцессные службы Обзор процесса

При запуске приложения Android создает процесс для запуска приложения. Как правило все компоненты приложения будет выполняться в рамках этого одного процесса. Службы Android являются исключением к этому, их можно настроить для работы в собственных процессов и совместно с другими приложениями, в том числе от других разработчиков Android. Такие типы служб называются _удаленной_ или _служб вне процесса_. Код для этих служб будет содержаться в одном пакете APK как основного приложения; Тем не менее, при запуске службы Android будет создан новый процесс для только что этой службы. Напротив, служба, которая запускается в том же процессе, что и остальные приложения, иногда называется _локальной службы_.

Как правило это необходимо для приложения для реализации удаленной службы. Локальная служба — достаточно (и желательно) для требований приложения во многих случаях. Вне процесса имеет собственную область памяти которой должен находиться под управлением Android. Несмотря на то, что это внедрять дополнительные издержки для приложения в целом, существуют некоторые сценарии, где может быть полезен для запуска службы в своем собственном процессе:

1. **Общий доступ к функциональности** &ndash; некоторые разработчики приложений могут иметь несколько приложений и функциональные возможности, общим для всех приложений. Упаковка эту функциональность в службу Android, в которой выполняется в отдельном процессе, могут упростить обслуживание приложения. Можно также упаковать в службу в свой собственный автономный пакет APK и развертывать отдельно от остальной части приложения.
2. **Улучшение взаимодействием с пользователем** &ndash; существует два возможных способа, что службу out-of-process можно улучшить взаимодействие с пользователем приложения. Первый способ имеет дело с управлением памятью. Сбор мусора (GC) цикла истечении Android будет приостановить все действия в процессе, пока сборщик Мусора не завершится. Пользователь может воспринимать как «дерганья изображения» или «jank» приостановить выполнение. Если служба работает его собственный процесс, это процесс службы, приостанавливается, не процесс приложения. Приостановить выполнение будет гораздо менее заметным, для пользователя, так как процесс приложения (и, следовательно, пользовательский интерфейс) не приостановлена.

    Во-вторых Если требования к памяти процесса становится слишком большим, Android может завершить этот процесс можно освободить ресурсы для устройства. Если служба имеет большой объем памяти, и он выполняется в том же процессе, что пользовательский Интерфейс, затем когда Android принудительно восстанавливает эти ресурсы пользовательского интерфейса завершит работу, что вынуждает пользователя для запуска приложения. Тем не менее при отключении службы, выполняющийся в отдельном процессе системой Android процесс пользовательского интерфейса остается без изменений. Пользовательский Интерфейс можно привязать (и перезапустить) службы, незаметно для пользователя и возобновления работы.

3. **Повышение производительности приложений** &ndash; процесс пользовательского интерфейса может быть завершен или завершение работы независимо от процесса службы. Переместив задачи запуска в службе вне процесса, вполне возможно, что время запуска пользовательского интерфейса может быть улучшена (предполагается, что процесс службы хранится между попыток запуска пользовательского интерфейса).

Во многих отношениях привязки к службе, работающей в другом процессе совпадает со значением [привязки к локальной службе](~/android/app-fundamentals/services/creating-a-service/bound-services.md). Клиент вызовет `BindService` для привязки (и запустить, при необходимости) службы. `Android.OS.IServiceConnection` Управлять взаимодействием между клиентом и службой будет создан объект. Если клиент успешно привязанной к службе, а затем возвращает объект, с помощью Android `IServiceConnection` , можно использовать для вызова методов в службе. Клиент затем взаимодействует со службой, с помощью этого объекта. Чтобы просмотреть, ниже приведены шаги для привязки к службе.

* **Создание объекта Intent** &ndash; явной целью должно использоваться для привязки к службе.
* **Реализация и создание их экземпляров `IServiceConnection` объект** &ndash; `IServiceConnection` объект выступает в качестве посредника между клиентом и службой.  Он отвечает за мониторинга подключения между клиентом и сервером.
* **Вызвать `BindService` метод** &ndash; вызова `BindService` передает цель и подключения службы, созданные на предыдущих шагах для Android, который позаботится о запуске службы и установка соединения между клиентом и службой.

Необходимость выходить за границы процесса вводят дополнительную сложность: связь является односторонней (клиент к серверу) и клиент не может напрямую вызвать методы в классе службы. Помните, что если служба выполняется тот же процесс, как клиент, Android предоставляет `IBinder` объект, который может обеспечить более двусторонний обмен данными. Это условие не выполняется, со службой, запущенной в отдельном процессе. Клиент взаимодействует с удаленной службой с помощью `Android.OS.Messenger` класса.

Если клиент запрашивает для привязки с удаленной службой, будут вызывать Android `Service.OnBind` метод жизненного цикла, который вернет внутренний `IBinder` объекта, которое инкапсулируется `Messenger`. `Messenger` Является тонкой оболочкой специальный `IBinder` реализация, которая предоставляется пакетом SDK для Android. `Messenger` Отвечает за обмен данными между двумя различными процессами. Разработчику не задумываться о со сведениями о сериализации сообщения, маршалинг сообщения через границу процесса и затем десериализует ее на стороне клиента. Эта работа обрабатывается `Messenger` объекта. На этой диаграмме показаны клиентские компоненты Android, задействованными при запуске клиентом привязки к службе вне процесса:

![Схема, показывающая шаги и компоненты для привязки к службе клиента](out-of-process-services-images/ipc-01.png "схема, показывающая шаги и компонентов для клиента, привязка к службе.")

`Service` Класс в удаленный процесс проходит через же жизненный цикл обратные вызовы, которые должен выполнить привязанной службы в локальном процессе, и многие API участвующих одинаковы. `Service.OnCreate` используется для инициализации `Handler` и вставим ее в `Messenger` объекта. Аналогичным образом `OnBind` переопределенный, но вместо возвращения `IBinder` объекта, служба вернет `Messenger`.  На этой схеме показано, что происходит в службе, если клиент привязка к нему:

![Схема, показывающая шаги и компоненты службы проходит через при привязке к удаленным клиентом](out-of-process-services-images/ipc-02.png "проходит схема, показывающая шаги и компоненты службы при привязке к удаленным клиентом.")

Когда `Message` принимается службой, оно обрабатывается в экземпляре `Android.OS.Handler`. Служба будет реализовать свой собственный `Handler` подкласс, в котором необходимо переопределить `HandleMessage` метод. Этот метод вызывается `Messenger` и получает `Message` как параметр. `Handler` Проверит `Message` метаданных и использовать эту информацию для вызова методов на службу.

Односторонний обмен данными происходит, когда клиент создает `Message` объекта и отправляет его службе, используя `Messenger.Send` метод. `Messenger.Send` Выполняет сериализацию `Message` и наличии этих сериализованных данных из системы, Android, который будет перенаправлять сообщения через границу процесса и службы.  `Messenger` , Размещенного на служба создаст `Message` объект входных данных. Это `Message` помещается в очередь, где сообщения, отправленного поочередно для `Handler`. `Handler` Проверит мета данные, содержащиеся в `Message` и вызова соответствующих методов на `Service`. На следующей схеме эти различные концепции, в действии:

![Схема, показывающая, как сообщения передаются между процессами](out-of-process-services-images/ipc-03.png "схема, показывающая, как сообщения передаются между процессами.")

В этом руководстве будет вдаваться в детали реализации службы вне процесса. Он расскажем о том, как реализовать службу, которая предназначена для выполнения в своем собственном процессе и как клиент может связаться с этой службы с помощью `Messenger` framework. Он также кратко обсудим двусторонний обмен данными: клиент, отправляющий сообщение в службу и службу, отправляя сообщение обратно клиенту. Поскольку службы могут совместно использоваться различными приложениями, в этом руководстве также обсуждаются методика, ограничивая доступ клиента к службе с помощью разрешения Android.

> [!IMPORTANT]
> [Bugzilla 1950 51940 и GitHub - происходит сбой разрешения перегрузки служб с помощью изолированные процессы и пользовательские приложения класса](https://github.com/xamarin/xamarin-android/issues/1950) отчеты, которые служба Xamarin.Android не будет запущен правильно при `IsolatedProcess` присваивается `true`. В этом руководстве приводится для справки. Приложения Xamarin.Android, по-прежнему сможете обмениваться данными со службой вне процесса, которая создается на языке Java.

## <a name="requirements"></a>Требования

В этом руководстве предполагается Знакомство с созданием службы.

Несмотря на то, что можно использовать неявные намерения с приложениями, предназначенных для более старых API Android, в этом руководстве основное внимание уделяется исключительно использование явных целей. Приложения, предназначенные для Android 5.0 (уровень API 21) или более поздней версии необходимо использовать явные цели для привязки в службе; это методика, в этом руководстве будут продемонстрированы...

## <a name="create-a-service-that-runs-in-a-separate-process"></a>Создать службу, которая выполняется в отдельном процессе

Как описано выше, тот факт, что служба работает в собственном процессе означает, что некоторые другие API-интерфейсы задействованы. Как краткий обзор ниже приведены шаги для привязки с и использование удаленной службы.  

* **Создание `Service` подкласс** &ndash; подкласс `Service` введите и реализовать методы жизненного цикла для привязки службы. Это также необходимо задать метаданные, появится соответствующее сообщение Android, который служба будет использовать в своем собственном процессе.
* **Реализуйте `Handler`**  &ndash; `Handler` отвечает за анализ клиентских запросов, извлечение все параметры, переданные от клиента и вызова соответствующих методов в службе.
* **Создать экземпляр `Messenger`**  &ndash; как описано выше, каждый `Service` необходимо поддерживать экземпляр `Messenger` класс, который будет направлять клиентские запросы на `Handler` , созданного на предыдущем шаге.

Это служба, которая предназначена для выполнения в своем собственном процессе является, по существу, по-прежнему привязанную службу. Класс службы расширит базовый `Service` класса и снабжен `ServiceAttribute` содержащий метаданных, которые необходимо объединить в манифест Android Android. Чтобы начать со следующих свойств объекта `ServiceAttribute` , важны в службу вне процесса:

1. `Exported` &ndash; Это свойство должно быть присвоено `true` других приложений для взаимодействия со службой. По умолчанию этому свойству присваивается значение `false`.
2. `Process` &ndash; Это свойство должно иметь значение. Он используется для указания имени процесса, который будет выполняться служба в.
3. `IsolatedProcess` &ndash; Это свойство будет включить дополнительную безопасность, о том, Android, чтобы запустить службу в изолированную "песочницу" с минимальным разрешением для взаимодействия с остальной частью системы. См. в разделе [Bugzilla 51940 - служб с помощью изолированных процессах и пользовательского класса приложения не смогут правильно разрешения перегрузок](https://bugzilla.xamarin.com/show_bug.cgi?id=51940).
4. `Permission` &ndash; Это можно контролировать доступ клиента к службе, указав разрешение, которое клиенты необходимо запросить (и предоставить).

Запуск службы в своем собственном процессе `Process` свойство `ServiceAttribute` должно быть присвоено имя службы. Для взаимодействия с внешние приложения `Exported` свойство должно быть присвоено `true`. Если `Exported` является `false`, а затем только клиенты в том же пакете APK (т. е. одного приложения) и работает в одном процессе будут иметь возможность взаимодействовать со службой.

Какого рода служба будет работать в процесс зависит от значения `Process` свойство. Android определяет три различных типа процессов:

-   **Процесс Private** &ndash; закрытый процесса — это приложения, будет доступно только для приложений, что и запустивший его. Для идентификации процесса как закрытый, его имя должно начинаться с **:** (точка с запятой). Услуги, упоминаемые в предыдущем фрагменте кода и снимок экрана — это закрытый процесс. В следующем фрагменте кода приведен пример `ServiceAttribute`:

    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             Process=":timestampservice_process",
             Exported=true)]
    ```

-   **Глобальные процесс** &ndash; услуга, которая выполняется в процессе глобального доступен для всех приложений на устройстве. Глобальные процесс должен быть полное имя класса, начинается с символа нижнего регистра.
    (Если не меры для защиты службы другие приложения могут привязать и взаимодействовать с ним. Защита службы от несанкционированного использования будет рассказано далее в этом руководстве.)

    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             Process="com.xamarin.xample.messengerservice.timestampservice_process",
             Exported=true)]
    ```

-   **Изолированный процесс** &ndash; изолированном процессе — это процесс, выполняемый в свой собственный "песочницы", изолированным от остальной системы и без специальных разрешений, свои собственные. Запуск службы в изолированном процессе, `IsolatedProcess` свойство `ServiceAttribute` присваивается `true` как показано в этом фрагменте кода:
    
    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             IsolatedProcess= true,
             Process="com.xamarin.xample.messengerservice.timestampservice_process",
             Exported=true)]
    ```

> [!IMPORTANT]
> См. в разделе [Bugzilla 51940 - служб с помощью изолированных процессах и пользовательского класса приложения не смогут правильно разрешения перегрузок](https://bugzilla.xamarin.com/show_bug.cgi?id=51940)

Изолированной службы — это простой способ защиты приложения и устройства от ненадежного кода. Например приложение может скачайте и запустите сценарий с веб-сайта. В этом случае это выполнение в изолированном процессе обеспечивает дополнительный уровень безопасности от ненадежного кода, компрометация на устройстве Android.

> [!IMPORTANT]
> После экспорта службы, не изменяйте имя службы. Изменение имени службы может разрушить других приложений, которые используют службу.

Чтобы увидеть результат, `Process` свойство, на следующем рисунке показаны службы, работающей в свой собственный закрытый процесс:

![Снимок экрана, показывающий службы, работающей в закрытый процесс](out-of-process-services-images/ipc-04.png "снимок экрана, показывающий службы, работающей в закрытый процесса.")

Этом далее снимке экрана показан `Process="com.xamarin.xample.messengerservice.timestampservice_process"` и службу, работающую в процессе глобального:

![Снимок экрана к службе, запущенной в процессе глобального](out-of-process-services-images/ipc-05.png "снимок службы, работающей в процессе глобального.")

Один раз `ServiceAttribute` был установлен, службы необходимо реализовать `Handler`.

### <a name="implementing-a-handler"></a>Реализация обработчика

Обрабатывать запросы клиентов, служба должна реализовывать `Handler` и переопределить `HandleMessage` methodThis является метод принимает `Message` экземпляр, который инкапсулирует вызов метода от клиента и преобразует, осуществляющих вызовы в некоторых действий или задач что будет выполнять служба. `Message` Объект предоставляет свойство с именем `What` которого является целое число, значение которого распределяется между клиентом и службой и связь с некоторой задачи, которая является выполнение для клиента службы.

В следующем фрагменте кода из примера приложения показан пример `HandleMessage`. В этом примере существует два действия, которые клиент может запрашивать службы:

* Первое действие — _Hello, World_ сообщение, клиент отправил простое сообщение в службу.
* Второе действие будет вызов метода на службы и получить строку, в этом случае строка будет сообщение, возвращающееся служба запущена и сколько его выполнение продолжалось в какое время:

```csharp
public class TimestampRequestHandler : Android.OS.Handler
{
    // other code omitted for clarity

    public override void HandleMessage(Message msg)
    {
        int messageType = msg.What;
        Log.Debug(TAG, $"Message type: {messageType}.");

        switch (messageType)
        {
            case Constants.SAY_HELLO_TO_TIMESTAMP_SERVICE:
                // The client as sent a simple Hello, say in the Android Log.
                break;

            case Constants.GET_UTC_TIMESTAMP:
                // Call methods on the service to retrieve a timestamp message.
                break;
            default:
                Log.Warn(TAG, $"Unknown messageType, ignoring the value {messageType}.");
                base.HandleMessage(msg);
                break;
        }
    }
}
```

Существует также возможность параметров пакета для службы в `Message`. Это будет рассматриваться далее в этом руководстве. Следующий раздел, которые следует учитывать при создании `Messenger` объекта для обработки входящего `Message`s.

### <a name="instantiating-the-messenger"></a>Создание экземпляра Messenger

Как уже упоминалось, десериализации `Message` объекта и вызова `Handler.HandleMessage` отвечает за `Messenger` объекта. `Messenger` Класс также предоставляет `IBinder` объекта, что клиент будет использовать для отправки сообщений в службу.  

При запуске службы, она создает экземпляр `Messenger` и внедрить `Handler`. Лучше всего выполнить эту инициализацию включен `OnCreate` метода службы. В этом фрагменте кода приведен пример того, это служба, которая инициализирует свой собственный `Handler` и `Messenger`:

```csharp
private Messenger messenger; // Instance variable for the Messenger

public override void OnCreate()
{
    base.OnCreate();
    messenger = new Messenger(new TimestampRequestHandler(this));
    Log.Info(TAG, $"TimestampService is running in process id {Android.OS.Process.MyPid()}.");
}
```

На этом этапе последним шагом является для `Service` для переопределения `OnBind`.

### <a name="implementing-serviceonbind"></a>Реализация Service.OnBind

Все связанные службы, независимо от места выполнения в собственном процессе или нет, необходимо реализовать `OnBind` метод. Возвращаемое значение этого метода является некоторые объекты, которые клиент может использовать для взаимодействия со службой. Именно то, что этот объект зависит от того, является ли служба локальной службы или удаленной службы. Хотя локальная служба будет возвращать пользовательский `IBinder` реализация, возвращает удаленную службу `IBinder` , инкапсулирован, но `Messenger` , созданного в предыдущем разделе:

```csharp
public override IBinder OnBind(Intent intent)
{
    Log.Debug(TAG, "OnBind");
    return messenger.Binder;
}
```

Как только эти три шага выполняются, удаленная служба может считаться завершенным.

## <a name="consuming-the-service"></a>Использование службы

Все клиенты должны реализовать код для привязки и использование удаленной службы. По существу с точки зрения клиента, существует очень мало различия между привязки для локальной службы или удаленной службы. Клиент вызывает `BindService` , передавая явной целью для идентификации службы и `IServiceConnection` которая помогает управлять соединение между клиентом и службой.

В этом фрагменте кода приведен пример создания **явным намерением** для привязки удаленной службы. Цель необходимо указать пакет, содержащий службы и имя службы. Один из способов установки эта информация является использование `Android.Content.ComponentName` объекта и для предоставления, с намерением. В этом фрагменте кода приведен пример:  

```csharp
// This is the package name of the APK, set in the Android manifest
const string REMOTE_SERVICE_COMPONENT_NAME = "com.xamarin.TimestampService";
// This is the name of the service, according the value of ServiceAttribute.Name
const string REMOTE_SERVICE_PACKAGE_NAME   = "com.xamarin.xample.messengerservice";

// Provide the package name and the name of the service with a ComponentName object.
ComponentName cn = new ComponentName(REMOTE_SERVICE_PACKAGE_NAME, REMOTE_SERVICE_COMPONENT_NAME);
Intent serviceToStart = new Intent();
serviceToStart.SetComponent(cn);
```

При привязке службы `IServiceConnection.OnServiceConnected` метод вызывается он предоставляет `IBinder` клиенту. Тем не менее, клиент не будет использовать напрямую `IBinder`. Вместо этого она создает экземпляр `Messenger` объект из, `IBinder`. Это `Messenger` , клиент будет использовать для взаимодействия с удаленной службой.

Ниже приведен пример очень простой `IServiceConnection` реализации, который демонстрирует, как клиент будет обрабатывать подключение и отключение от службы. Обратите внимание, что `OnServiceConnected` метод получает и `IBinder`, и клиент создает `Messenger` , `IBinder`:

```csharp
public class TimestampServiceConnection : Java.Lang.Object, IServiceConnection
{
    static readonly string TAG = typeof(TimestampServiceConnection).FullName;

    MainActivity mainActivity;
    Messenger messenger;

    public TimestampServiceConnection(MainActivity activity)
    {
        IsConnected = false;
        mainActivity = activity;
    }

    public bool IsConnected { get; private set; }
    public Messenger Messenger { get; private set; }

    public void OnServiceConnected(ComponentName name, IBinder service)
    {
        Log.Debug(TAG, $"OnServiceConnected {name.ClassName}");

        IsConnected = service != null
        Messenger = new Messenger(service);

        if (IsConnected)
        {
            // things to do when the connection is successful. perhaps notify the client? enable UI features?
        }
        else
        {
            // things to do when the connection isn't successful.
        }
    }

    public void OnServiceDisconnected(ComponentName name)
    {
        Log.Debug(TAG, $"OnServiceDisconnected {name.ClassName}");
        IsConnected = false;
        Messenger = null;

        // Things to do when the service disconnects. perhaps notify the client? disable UI features?

    }
}
```

После создания подключения службы и только это возможно для клиента для вызова `BindService` и инициации процесса привязки:

```csharp
IServiceConnection serviceConnection = new TimestampServiceConnection(this);
BindActivity(serviceToStart, serviceConnection, Bind.AutoCreate);
```

После клиент успешно привязан к службе и `Messenger` — доступны, существует возможность, чтобы клиент отправлял `Messages` к службе.

## <a name="sending-messages-to-the-service"></a>Отправка сообщений в службу

После того как клиент подключен и имеет `Messenger` объекта, существует возможность взаимодействия со службой путем отправки `Message` объектов с помощью `Messenger`. Это взаимодействие является односторонней, клиент отправляет сообщение, но нет возвращаемого сообщения от службы клиенту. В этом отношении `Message` — это механизм выстрелил и забыл.

Рекомендуемый способ создания `Message` объекта заключается в использовании [ `Message.Obtain` ](https://developer.xamarin.com/api/type/Android.OS.Message/#Public%20Methods) метод фабрики. Этот метод извлечет `Message` объект из глобального пула, который ведется с Android. `Message.Obtain` также имеет некоторые перегруженные методы, позволяющие `Message` объект, инициализируемый со значениями и параметры, необходимые для службы.  Один раз `Message` будет создан, его отправить службе, вызвав `Messenger.Send`. В этом фрагменте приведен пример того, создание и отправка `Message` к процессу службы:

```csharp
Message msg = Message.Obtain(null, Constants.SAY_HELLO_TO_TIMESTAMP_SERVICE);
try
{
    serviceConnection.Messenger.Send(msg);
}
catch (RemoteException ex)
{
    Log.Error(TAG, ex, "There was a error trying to send the message.");
}
```

Существует несколько различных форм `Message.Obtain` метод. В предыдущем примере используется [ `Message.Obtain(Handler h, Int32 what)` ](https://developer.xamarin.com/api/member/Android.OS.Message.Obtain/p/Android.OS.Handler/System.Int32/). Поскольку это асинхронный запрос к службе вне процесса; будет существовать нет ответа от службы, поэтому `Handler` присваивается `null`. Второй параметр, `Int32 what`, будут храниться в `.What` свойство `Message` объекта. `.What` Свойство используется код в процесс службы для вызова методов в службе.

`Message` Класс также предоставляет два дополнительных свойства, которые могут оказаться полезными для получателя: `Arg1` и `Arg2`. Эти два свойства: целочисленных значений, которые могут иметь некоторые специальные согласованные значения, которые имеют значение между клиентом и службой. Например `Arg1` может содержать идентификатор клиента и `Arg2` может содержать номер заказа на покупку для этого клиента. [ `Method.Obtain(Handler h, Int32 what, Int32 arg1, Int32 arg2)` ](https://developer.xamarin.com/api/member/Android.OS.Message.Obtain/p/Android.OS.Handler/System.Int32/System.Int32/System.Int32/) Позволяют задать два свойства при `Message` создается. Еще один способ заполнения этих двух значений — присвоить `.Arg` и `.Arg2` свойства непосредственно на `Message` объекта после его создания.

### <a name="passing-additional-values-to-the-service"></a>Передача дополнительных значений в службу

Можно передать службе более сложных данных с помощью `Bundle`. В этом случае можно поместить дополнительные значения в `Bundle` и отправленные вместе с `Message` , задав [ `.Data` свойство](https://developer.xamarin.com/api/property/Android.OS.Message.Data/) свойство перед отправкой.

```csharp
Bundle serviceParameters = new Bundle();
serviceParameters.

var msg = Message.Obtain(null, Constants.SERVICE_TASK_TO_PERFORM);
msg.Data = serviceParameters;

messenger.Send(msg);
```


> [!NOTE]
> В общем случае `Message` не должны иметь полезных данных, размер которых превышает 1 МБ. Ограничение размера может зависеть от версии Android и на собственные изменения могли сделать поставщика к их реализации из Android откройте исходный проект (AOSP), входит в состав устройства.

## <a name="returning-values-from-the-service"></a>Возврат значений из службы

Архитектура обработки сообщений, см. на данный момент является односторонней, клиент отправляет сообщение службе. Если это необходимо для службы для возврата значения клиенту затем отменяется все, что описан в эту точку. Служба должна создать `Message`, упакованных все возвращаемые значения и диспетчеризации `Message` через `Messenger` клиенту. Тем не менее, служба не создавать собственную `Messenger`; вместо этого он полагается на создание экземпляра клиента и пакет `Messenger` как часть исходного запроса. Служба будет `Send` сообщение с помощью предоставленных этом клиентом `Messenger`.  

Последовательность событий для двустороннего обмена данными такова:

1. Клиент выполняет привязку к службе. При подключении служба и клиент, `IServiceConnection` , обслуживаемый клиент будет иметь ссылку на `Messenger` объект, используемый для передачи `Message`s для службы. Чтобы избежать путаницы, это будет называться _Service Messenger_.
2. Клиент создает экземпляр `Handler` (называется _клиентский обработчик_) и использует его для инициализации свой собственный `Messenger` ( _Messenger клиента_). Обратите внимание, что служба Messenger и Messenger клиента двух разных объектов, которые обрабатывают трафик в двух разных направлениях. Messenger службы обрабатывает сообщения от клиента к службе, хотя Messenger клиента будет обрабатывать сообщения от службы клиенту.
3. Клиент создает `Message` , а свойству `ReplyTo` свойство с Messenger клиента. Сообщение затем отправляется в службу с помощью службы Messenger.
4. Служба получает сообщение от клиента и выполняет запрашиваемую работу.
5. Когда все готово для отправки ответа клиенту службы будет использоваться `Message.Obtain` для создания нового `Message` объекта.
6. Чтобы отправить это сообщение клиенту, служба извлечет Messenger клиента из `.ReplyTo` свойство клиента сообщения и использовать его для `.Send` `Message` обратно клиенту.
7. Когда клиент получает ответ, он имеет свой собственный `Handler` обрабатывать `Message` , проверяя `.What` свойство (и при необходимости извлечения параметров, содержащихся в `Message`).

В этом примере кода показано, как клиент создает экземпляр `Message` и упаковать `Messenger` , служба должна использовать для ответа:

```csharp
Handler clientHandler = new ActivityHandler();
Messenger clientMessenger = new Messenger(activityHandler);

Message msg = Message.Obtain(null, Constants.GET_UTC_TIMESTAMP);
msg.ReplyTo = clientMessenger;

try
{
    serviceConnection.Messenger.Send(msg);
}
catch (RemoteException ex)
{
    Log.Error(TAG, ex, "There was a problem sending the message.");
}
```

Службы необходимо внести некоторые изменения в свой собственный `Handler` для извлечения `Messenger` и используйте его для отправки ответов клиенту. В этом фрагменте кода приведен пример того, как службы `Handler` создаст `Message` и отправить его обратно клиенту:  

```csharp
// This is the message that the service will send to the client.
Message responseMessage = Message.Obtain(null, Constants.RESPONSE_TO_SERVICE);
Bundle dataToReturn = new Bundle();
dataToReturn.PutString(Constants.RESPONSE_MESSAGE_KEY, "This is the result from the service.");
responseMessage.Data = dataToReturn;

// The msg object here is the message that was received by the service. The service will not instantiate a client,
// It will use the client that is encapsulated by the message from the client.
Messenger clientMessenger = msg.ReplyTo;
if (clientMessenger!= null)
{
    try
    {
        clientMessenger.Send(responseMessage);
    }
    catch (Exception ex)
    {
        Log.Error(TAG, ex, "There was a problem sending the message.");
    }
}
```

Обратите внимание, что в примерах выше, `Messenger` экземпляр, который создается с помощью клиента *не* тот же объект, полученных службой. Это могут быть две различных `Messenger` объектов, выполняемых в двух разных процессах, которые представляют канала связи.

## <a name="securing-the-service-with-android-permissions"></a>Защита службы с разрешениями на Android

Это служба, которая выполняется в процессе глобального становится доступным для всех приложений, работающих на этом устройстве Android. В некоторых ситуациях это открытость и доступности является нежелательным и необходимо защитить службу от доступа из неавторизованных клиентов. Для ограничения доступа к удаленной службе рекомендуется использовать разрешения Android.

Разрешения можно определить по `Permission` свойство `ServiceAttribute` который оформляет `Service` подклассом. Это будет имя разрешение, которое клиент должен предоставляться при привязке к службе. Если клиент не имеет соответствующих разрешений, а затем вызовет Android `Java.Lang.SecurityException` когда клиент пытается осуществить привязку к службе.

Существует четыре разрешения различных уровней, которые предоставляет Android:

* **Обычный** &ndash; это уровень разрешений по умолчанию. Он используется для определения разрешений низким уровнем риска, которые могут автоматически предоставляться системой Android их клиенты. Пользователю не нужно явно предоставить эти разрешения, но разрешения можно просмотреть в параметрах приложения.
* **подпись** &ndash; это специальная категория разрешения, будут автоматически предоставлены с Android для приложений, которые подписаны тем же сертификатом. Это разрешение позволяет сделать его без труда для разработчиков приложений, совместно использовать компоненты, а также данные между свои приложения без обращения к специалистам пользователя для констант утверждений.
* **signatureOrSystem** &ndash; это очень похоже на **подпись** разрешения, описанные выше. Кроме того, что автоматически предоставляются для приложений, которые подписаны тем же сертификатом, это разрешение также будет предоставлено для приложений, подписанных установлен тот же сертификат, который использовался для подписания приложений с помощью образа системы Android. Это разрешение обычно только позволяет разработчикам Android ПЗУ свои приложения для работы со сторонними приложениями. Обычно он не используется в приложениях, предназначены общего распространения для широкой публики.
* **опасные** &ndash; опасные разрешения, которые может вызвать проблемы для пользователя. По этой причине **опасных** разрешения должны утверждаться пользователем явно.

Так как `signature` и `normal` разрешения автоматически предоставляются во время установленного системой Android, очень важно, что установлен пакет APK, где размещается служба **перед** apk-ФАЙЛ, содержащий клиент. Если клиент устанавливается во-первых, Android не будет предоставить разрешения. В этом случае он будет необходимо удалить клиент APK, установите службу apk-ФАЙЛ и затем заново установить клиент пакета APK.

Существуют два распространенных способа защиты службы с помощью разрешения Android:

1.  **Реализуйте безопасность на уровне подпись** &ndash; безопасность на уровне подписи означает, что разрешение предоставляется автоматически для тех приложений, которые должны быть подписаны тем же ключом, который был использован для подписывания apk-ФАЙЛ, содержащий службы. Это простой способ для разработчиков для защиты своей службы, но остаться доступным из своих приложений. Разрешения на уровне подпись объявляются, задав `Permission` свойство `ServiceAttribute` для `signature`:

    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             Process="com.xamarin.TimestampService.timestampservice_process",
             Permission="signature")]
    public class TimestampService : Service
    {
    }
    ```

2.  **Создать пользовательское разрешение** &ndash; возможно для разработчиков службы для создания пользовательских разрешений для службы. Это подходит, когда разработчику необходимо предоставить службе приложения других разработчиков. Настраиваемое разрешение требует немного больше усилий для реализации и будет рассматриваться ниже.

Упрощенный пример создания настраиваемой `normal` разрешения будут описаны в следующем разделе. Дополнительные сведения о разрешениях для Android, обратитесь к документации по Google для [рекомендации и безопасность](https://developer.android.com/training/articles/security-tips.html). Дополнительные сведения о разрешениях для Android см. в разделе [разрешения](https://developer.android.com/guide/topics/manifest/manifest-intro.html#perms) документации по Android манифест приложения, Дополнительные сведения о разрешениях для Android.

> [!NOTE]
> В общем случае [Google не рекомендуется использовать пользовательские разрешения](https://developer.android.com/training/articles/security-tips.html#RequestingPermissions) как может оказаться заблуждение пользователей.

### <a name="creating-a-custom-permission"></a>Создание пользовательского разрешения

Чтобы использовать настраиваемое разрешение, она объявлена службой, пока клиент явно запрашивает такое разрешение.

Создание разрешения в службе APK, `permission` добавляется элемент `manifest` элемент в **AndroidManifest.xml**. Это разрешение необходимо иметь `name`, `protectionLevel`, и `label` наборами атрибутов. `name` Атрибута необходимо задать строку, однозначно определяющее разрешение. Имя будет отображаться в **App Info** представление **параметры Android** (как показано в следующем разделе).

`protectionLevel` Атрибута должно быть присвоено одно из четырех строковые значения, которые были описаны выше.  `label` И `description` должен ссылаться на строковые ресурсы и используются для предоставления понятное имя и описание для пользователя.

В этом фрагменте приведен пример объявления пользовательского `permission` атрибут в **AndroidManifest.xml** пакета APK, которая содержит службу:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          android:versionCode="1"
          android:versionName="1.0"
          package="com.xamarin.xample.messengerservice">

    <uses-sdk android:minSdkVersion="21" />

    <permission android:name="com.xamarin.xample.messengerservice.REQUEST_TIMESTAMP"
                android:protectionLevel="signature"
                android:label="@string/permission_label"
                android:description="@string/permission_description"
                />

    <application android:allowBackup="true"
            android:icon="@mipmap/icon"
            android:label="@string/app_name"
            android:theme="@style/AppTheme">

    </application>
</manifest>
```

Затем **AndroidManifest.xml** клиента APK необходимо явно запросить это новое разрешение. Это делается путем добавления `users-permission` атрибут **AndroidManifest.xml**:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          android:versionCode="1"
          android:versionName="1.0"
          package="com.xamarin.xample.messengerclient">

    <uses-sdk android:minSdkVersion="21" />

    <uses-permission android:name="com.xamarin.xample.messengerservice.REQUEST_TIMESTAMP" />

    <application
            android:allowBackup="true"
            android:icon="@mipmap/icon"
            android:label="@string/app_name"
            android:theme="@style/AppTheme">
    </application>
    </manifest>
```

### <a name="view-the-permissions-granted-to-an-app"></a>Просмотреть разрешения, предоставленные в приложение

Чтобы просмотреть разрешения, которые были предоставлены приложения, откройте приложение "Параметры Android" и выберите **приложений**. Найдите и выберите приложение в списке. Из **App Info** коснитесь **разрешения** которого приведет к появлению представление, в котором отображаются все разрешения, предоставленные приложению:

[![Снимки экрана на устройстве Android, в котором показано, как найти разрешения, предоставленные приложению](out-of-process-services-images/ipc-06-sml.png)](out-of-process-services-images/ipc-06.png#lightbox)

## <a name="summary"></a>Сводка

В этом руководстве было дополнительно обсуждение как запустить службу Android в удаленном процессе. Различия между локальной и удаленной службы был объяснялось, а также некоторые причины, почему удаленной службы может быть полезным стабильности и производительности приложения Android. После объяснения, как реализовать удаленной службы и как клиент может связаться со службой, руководство объяснили, предоставляют один способ ограничить доступ к службе из только авторизованные клиенты.


## <a name="related-links"></a>Связанные ссылки

- [Обработчик](https://developer.xamarin.com/api/type/Android.OS.Handler/)
- [Сообщение](https://developer.xamarin.com/api/type/Android.OS.Message/)
- [Messenger](https://developer.xamarin.com/api/type/Android.OS.Messenger/)
- [ServiceAttribute](https://developer.xamarin.com/api/type/Android.App.ServiceAttribute)
- [Атрибут экспорта](https://developer.android.com/guide/topics/manifest/service-element.html#exported)
- [Происходит сбой разрешения перегрузки служб с изолированных процессах и пользовательский класс приложения](https://bugzilla.xamarin.com/show_bug.cgi?id=51940)
- [Процессы и потоки](https://developer.android.com/guide/components/processes-and-threads.html)
- [Манифест Android - разрешения](https://developer.android.com/guide/topics/manifest/manifest-intro.html#perms)
- [Советы по безопасности](https://developer.android.com/training/articles/security-tips.html)
- [MessengerServiceDemo (пример)](https://developer.xamarin.com/samples/monodroid/ApplicationFundamentals/ServiceSamples/MessengerServiceDemo/)
